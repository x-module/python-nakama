# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: nakama.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

import betterproto


class FriendState(betterproto.Enum):
    """The friendship status."""

    # The user is a friend of the current user.
    FRIEND = 0
    # The current user has sent an invite to the user.
    INVITE_SENT = 1
    # The current user has received an invite from this user.
    INVITE_RECEIVED = 2
    # The current user has blocked this user.
    BLOCKED = 3


class UserRoleState(betterproto.Enum):
    """The group role status."""

    # The user is a superadmin with full control of the group.
    SUPERADMIN = 0
    # The user is an admin with additional privileges.
    ADMIN = 1
    # The user is a regular member.
    MEMBER = 2
    # The user has requested to join the group
    JOIN_REQUEST = 3


class StoreProvider(betterproto.Enum):
    """Validation Provider,"""

    # Apple App Store
    APPLE_APP_STORE = 0
    # Google Play Store
    GOOGLE_PLAY_STORE = 1
    # Huawei App Gallery
    HUAWEI_APP_GALLERY = 2


class StoreEnvironment(betterproto.Enum):
    """Environment where a purchase/subscription took place,"""

    # Unknown environment.
    UNKNOWN = 0
    # Sandbox/test environment.
    SANDBOX = 1
    # Production environment.
    PRODUCTION = 2


class OpType(betterproto.Enum):
    """
    Operator that can be used to override the one set in the leaderboard.
    """

    # Do not override the leaderboard operator.
    NO_OVERRIDE = 0
    # Override the leaderboard operator with BEST.
    BEST = 1
    # Override the leaderboard operator with SET.
    SET = 2
    # Override the leaderboard operator with INCREMENT.
    INCREMENT = 3
    # Override the leaderboard operator with DECREMENT.
    DECREMENT = 4


@dataclass
class HealthcheckRequest(betterproto.Message):
    """Healthcheck request."""

    pass


@dataclass
class AccountRequest(betterproto.Message):
    """Account request."""

    pass


@dataclass
class AccountResponse(betterproto.Message):
    """A user with additional account details. Always the current user."""

    # The user object.
    user: "User" = betterproto.message_field(1)
    # The user's wallet data.
    wallet: str = betterproto.string_field(2)
    # The email address of the user.
    email: str = betterproto.string_field(3)
    # The devices which belong to the user's account.
    devices: List["AccountDevice"] = betterproto.message_field(4)
    # The custom id in the user's account.
    custom_id: str = betterproto.string_field(5)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user's email was verified.
    verify_time: datetime = betterproto.message_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user's account was disabled/banned.
    disable_time: datetime = betterproto.message_field(7)


@dataclass
class AccountRefresh(betterproto.Message):
    """Obtain a new authentication token using a refresh token."""

    # Refresh token.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountApple(betterproto.Message):
    """
    Send a Apple Sign In token to the server. Used with
    authenticate/link/unlink.
    """

    # The ID token received from Apple to validate.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountCustom(betterproto.Message):
    """Send a custom ID to the server. Used with authenticate/link/unlink."""

    # A custom identifier.
    id: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountDevice(betterproto.Message):
    """
    Send a device to the server. Used with authenticate/link/unlink and user.
    """

    # A device identifier. Should be obtained by a platform-specific device API.
    id: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountEmail(betterproto.Message):
    """
    Send an email with password to the server. Used with
    authenticate/link/unlink.
    """

    # A valid RFC-5322 email address.
    email: str = betterproto.string_field(1)
    # A password for the user account.
    password: str = betterproto.string_field(2)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountFacebook(betterproto.Message):
    """
    Send a Facebook token to the server. Used with authenticate/link/unlink.
    """

    # The OAuth token received from Facebook to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountFacebookInstantGame(betterproto.Message):
    """
    Send a Facebook Instant Game token to the server. Used with
    authenticate/link/unlink.
    """

    # The OAuth token received from a Facebook Instant Game that may be decoded
    # with the Application Secret (must be available with the nakama
    # configuration)
    signed_player_info: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountGameCenter(betterproto.Message):
    """
    Send Apple's Game Center account credentials to the server. Used with
    authenticate/link/unlink.
    """

    # Player ID (generated by GameCenter).
    player_id: str = betterproto.string_field(1)
    # Bundle ID (generated by GameCenter).
    bundle_id: str = betterproto.string_field(2)
    # Time since UNIX epoch when the signature was created.
    timestamp_seconds: int = betterproto.int64_field(3)
    # A random "NSString" used to compute the hash and keep it randomized.
    salt: str = betterproto.string_field(4)
    # The verification signature data generated.
    signature: str = betterproto.string_field(5)
    # The URL for the public encryption key.
    public_key_url: str = betterproto.string_field(6)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        7, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountGoogle(betterproto.Message):
    """
    Send a Google token to the server. Used with authenticate/link/unlink.
    """

    # The OAuth token received from Google to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountSteam(betterproto.Message):
    """
    Send a Steam token to the server. Used with authenticate/link/unlink.
    """

    # The account token received from Steam to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AddFriendsRequest(betterproto.Message):
    """Add one or more friends to the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class AddGroupUsersRequest(betterproto.Message):
    """Add users to a group."""

    # The group to add users to.
    group_id: str = betterproto.string_field(1)
    # The users to add.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class SessionRefreshRequest(betterproto.Message):
    """Authenticate against the server with a refresh token."""

    # Refresh token.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class SessionLogoutRequest(betterproto.Message):
    """
    Log out a session, invalidate a refresh token, or log out all
    sessions/refresh tokens for a user.
    """

    # Session token to log out.
    token: str = betterproto.string_field(1)
    # Refresh token to invalidate.
    refresh_token: str = betterproto.string_field(2)


@dataclass
class AuthenticateAppleRequest(betterproto.Message):
    """Authenticate against the server with Apple Sign In."""

    # The Apple account details.
    account: "AccountApple" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateCustomRequest(betterproto.Message):
    """Authenticate against the server with a custom ID."""

    # The custom account details.
    account: "AccountCustom" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateDeviceRequest(betterproto.Message):
    """Authenticate against the server with a device ID."""

    # The device account details.
    account: "AccountDevice" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateEmailRequest(betterproto.Message):
    """Authenticate against the server with email+password."""

    # The email account details.
    account: "AccountEmail" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateFacebookRequest(betterproto.Message):
    """Authenticate against the server with Facebook."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)
    # Import Facebook friends for the user.
    sync: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)


@dataclass
class AuthenticateFacebookInstantGameRequest(betterproto.Message):
    """Authenticate against the server with Facebook Instant Game token."""

    # The Facebook Instant Game account details.
    account: "AccountFacebookInstantGame" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateGameCenterRequest(betterproto.Message):
    """Authenticate against the server with Apple's Game Center."""

    # The Game Center account details.
    account: "AccountGameCenter" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateGoogleRequest(betterproto.Message):
    """Authenticate against the server with Google."""

    # The Google account details.
    account: "AccountGoogle" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateSteamRequest(betterproto.Message):
    """Authenticate against the server with Steam."""

    # The Steam account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)
    # Import Steam friends for the user.
    sync: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)


@dataclass
class BanGroupUsersRequest(betterproto.Message):
    """Ban users from a group."""

    # The group to ban users from.
    group_id: str = betterproto.string_field(1)
    # The users to ban.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class BlockFriendsRequest(betterproto.Message):
    """Block one or more friends for the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class ChannelMessage(betterproto.Message):
    """A message sent on a channel."""

    # The channel this message belongs to.
    channel_id: str = betterproto.string_field(1)
    # The unique ID of this message.
    message_id: str = betterproto.string_field(2)
    # The code representing a message type or category.
    code: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # Message sender, usually a user ID.
    sender_id: str = betterproto.string_field(4)
    # The username of the message sender, if any.
    username: str = betterproto.string_field(5)
    # The content payload.
    content: str = betterproto.string_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was created.
    create_time: datetime = betterproto.message_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was last updated.
    update_time: datetime = betterproto.message_field(8)
    # True if the message was persisted to the channel's history, false
    # otherwise.
    persistent: Optional[bool] = betterproto.message_field(
        9, wraps=betterproto.TYPE_BOOL
    )
    # The name of the chat room, or an empty string if this message was not sent
    # through a chat room.
    room_name: str = betterproto.string_field(10)
    # The ID of the group, or an empty string if this message was not sent
    # through a group channel.
    group_id: str = betterproto.string_field(11)
    # The ID of the first DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_one: str = betterproto.string_field(12)
    # The ID of the second DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_two: str = betterproto.string_field(13)


@dataclass
class ChannelMessagesResponse(betterproto.Message):
    """A list of channel messages, usually a result of a list operation."""

    # A list of messages.
    messages: List["ChannelMessage"] = betterproto.message_field(1)
    # The cursor to send when retrieving the next page, if any.
    next_cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)
    # Cacheable cursor to list newer messages. Durable and designed to be stored,
    # unlike next/prev cursors.
    cacheable_cursor: str = betterproto.string_field(4)


@dataclass
class CreateGroupRequest(betterproto.Message):
    """Create a group with the current user as owner."""

    # A unique name for the group.
    name: str = betterproto.string_field(1)
    # A description for the group.
    description: str = betterproto.string_field(2)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(3)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(4)
    # Mark a group as open or not where only admins can accept members.
    open: bool = betterproto.bool_field(5)
    # Maximum number of group members.
    max_count: int = betterproto.int32_field(6)


@dataclass
class DeleteFriendsRequest(betterproto.Message):
    """Delete one or more friends for the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class DeleteGroupRequest(betterproto.Message):
    """Delete a group the user has access to."""

    # The id of a group.
    group_id: str = betterproto.string_field(1)


@dataclass
class DeleteLeaderboardRecordRequest(betterproto.Message):
    """Delete a leaderboard record."""

    # The leaderboard ID to delete from.
    leaderboard_id: str = betterproto.string_field(1)


@dataclass
class DeleteNotificationsRequest(betterproto.Message):
    """Delete one or more notifications for the current user."""

    # The id of notifications.
    ids: List[str] = betterproto.string_field(1)


@dataclass
class DeleteTournamentRecordRequest(betterproto.Message):
    """Delete a leaderboard record."""

    # The tournament ID to delete from.
    tournament_id: str = betterproto.string_field(1)


@dataclass
class DeleteStorageObjectId(betterproto.Message):
    """Storage objects to delete."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The version hash of the object.
    version: str = betterproto.string_field(3)


@dataclass
class DeleteStorageObjectsRequest(betterproto.Message):
    """Batch delete storage objects."""

    # Batch of storage objects.
    object_ids: List["DeleteStorageObjectId"] = betterproto.message_field(1)


@dataclass
class EventRequest(betterproto.Message):
    """
    Represents an event to be passed through the server to registered event
    handlers.
    """

    # An event name, type, category, or identifier.
    name: str = betterproto.string_field(1)
    # Arbitrary event property values.
    properties: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # The time when the event was triggered.
    timestamp: datetime = betterproto.message_field(3)
    # True if the event came directly from a client call, false otherwise.
    external: bool = betterproto.bool_field(4)


@dataclass
class Friend(betterproto.Message):
    """A friend of a user."""

    # The user object.
    user: "User" = betterproto.message_field(1)
    # The friend status. -- use enum FriendState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # Time of the latest relationship update.
    update_time: datetime = betterproto.message_field(3)


@dataclass
class FriendsResponse(betterproto.Message):
    """A collection of zero or more friends of the user."""

    # The Friend objects.
    friends: List["Friend"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class UsersRequest(betterproto.Message):
    """Fetch a batch of zero or more users from the server."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)
    # The Facebook ID of a user.
    facebook_ids: List[str] = betterproto.string_field(3)


@dataclass
class SubscriptionRequest(betterproto.Message):
    """Fetch a subscription by product id."""

    # Product id of the subscription
    product_id: str = betterproto.string_field(1)


@dataclass
class Group(betterproto.Message):
    """A group in the server."""

    # The id of a group.
    id: str = betterproto.string_field(1)
    # The id of the user who created the group.
    creator_id: str = betterproto.string_field(2)
    # The unique name of the group.
    name: str = betterproto.string_field(3)
    # A description for the group.
    description: str = betterproto.string_field(4)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(5)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(6)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(7)
    # Anyone can join open groups, otherwise only admins can accept members.
    open: Optional[bool] = betterproto.message_field(8, wraps=betterproto.TYPE_BOOL)
    # The current count of all members in the group.
    edge_count: int = betterproto.int32_field(9)
    # The maximum number of members allowed.
    max_count: int = betterproto.int32_field(10)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # group was created.
    create_time: datetime = betterproto.message_field(11)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # group was last updated.
    update_time: datetime = betterproto.message_field(12)


@dataclass
class GroupsResponse(betterproto.Message):
    """One or more groups returned from a listing operation."""

    # One or more groups.
    groups: List["Group"] = betterproto.message_field(1)
    # A cursor used to get the next page.
    cursor: str = betterproto.string_field(2)


@dataclass
class GroupUser(betterproto.Message):
    """A single user-role pair."""

    # User.
    user: "User" = betterproto.message_field(1)
    # Their relationship to the group. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)


@dataclass
class GroupUsersResponse(betterproto.Message):
    """A list of users belonging to a group, along with their role."""

    # User-role pairs for a group.
    group_users: List["GroupUser"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class ImportFacebookFriendsRequest(betterproto.Message):
    """Import Facebook friends into the current user's account."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Reset the current user's friends list.
    reset: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ImportSteamFriendsRequest(betterproto.Message):
    """Import Facebook friends into the current user's account."""

    # The Facebook account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Reset the current user's friends list.
    reset: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class JoinGroupRequest(betterproto.Message):
    """Immediately join an open group, or request to join a closed one."""

    # The group ID to join. The group must already exist.
    group_id: str = betterproto.string_field(1)


@dataclass
class JoinTournamentRequest(betterproto.Message):
    """The request to join a tournament."""

    # The ID of the tournament to join. The tournament must already exist.
    tournament_id: str = betterproto.string_field(1)


@dataclass
class KickGroupUsersRequest(betterproto.Message):
    """Kick a set of users from a group."""

    # The group ID to kick from.
    group_id: str = betterproto.string_field(1)
    # The users to kick.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class Leaderboard(betterproto.Message):
    """A leaderboard on the server."""

    # The ID of the leaderboard.
    id: str = betterproto.string_field(1)
    # ASC(0) or DESC(1) sort mode of scores in the leaderboard.
    sort_order: int = betterproto.uint32_field(2)
    # BEST, SET, INCREMENT or DECREMENT operator mode of the leaderboard.
    operator: "OpType" = betterproto.enum_field(3)
    # The UNIX time when the leaderboard was previously reset. A computed value.
    prev_reset: int = betterproto.uint32_field(4)
    # The UNIX time when the leaderboard is next playable. A computed value.
    next_reset: int = betterproto.uint32_field(5)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard was created.
    create_time: datetime = betterproto.message_field(7)
    # Whether the leaderboard was created authoritatively or not.
    authoritative: bool = betterproto.bool_field(8)


@dataclass
class LeaderboardsResponse(betterproto.Message):
    """A list of leaderboards"""

    # The list of leaderboards returned.
    leaderboards: List["Leaderboard"] = betterproto.message_field(1)
    # A pagination cursor (optional).
    cursor: str = betterproto.string_field(2)


@dataclass
class LeaderboardRecord(betterproto.Message):
    """
    Represents a complete leaderboard record with all scores and associated
    metadata.
    """

    # The ID of the leaderboard this score belongs to.
    leaderboard_id: str = betterproto.string_field(1)
    # The ID of the score owner, usually a user or group.
    owner_id: str = betterproto.string_field(2)
    # The username of the score owner, if the owner is a user.
    username: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # The score value.
    score: int = betterproto.int64_field(4)
    # An optional subscore value.
    subscore: int = betterproto.int64_field(5)
    # The number of submissions to this score record.
    num_score: int = betterproto.int32_field(6)
    # Metadata.
    metadata: str = betterproto.string_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record was created.
    create_time: datetime = betterproto.message_field(8)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record was updated.
    update_time: datetime = betterproto.message_field(9)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record expires.
    expiry_time: datetime = betterproto.message_field(10)
    # The rank of this record.
    rank: int = betterproto.int64_field(11)
    # The maximum number of score updates allowed by the owner.
    max_num_score: int = betterproto.uint32_field(12)


@dataclass
class LeaderboardRecordsResponse(betterproto.Message):
    """
    A set of leaderboard records, may be part of a leaderboard records page or
    a batch of individual records.
    """

    # A list of leaderboard records.
    records: List["LeaderboardRecord"] = betterproto.message_field(1)
    # A batched set of leaderboard records belonging to specified owners.
    owner_records: List["LeaderboardRecord"] = betterproto.message_field(2)
    # The cursor to send when retrieving the next page, if any.
    next_cursor: str = betterproto.string_field(3)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(4)


@dataclass
class LeaveGroupRequest(betterproto.Message):
    """Leave a group."""

    # The group ID to leave.
    group_id: str = betterproto.string_field(1)


@dataclass
class LinkFacebookRequest(betterproto.Message):
    """Link Facebook to the current user's account."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Import Facebook friends for the user.
    sync: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class LinkSteamRequest(betterproto.Message):
    """Link Steam to the current user's account."""

    # The Facebook account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Import Steam friends for the user.
    sync: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ChannelMessagesRequest(betterproto.Message):
    """List a channel's message history."""

    # The channel ID to list from.
    channel_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # True if listing should be older messages to newer, false if reverse.
    forward: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)
    # A pagination cursor, if any.
    cursor: str = betterproto.string_field(4)


@dataclass
class FriendsRequest(betterproto.Message):
    """List friends for a user."""

    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # The friend state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(3)


@dataclass
class GroupsRequest(betterproto.Message):
    """List groups based on given filters."""

    # List groups that contain this value in their names.
    name: str = betterproto.string_field(1)
    # Optional pagination cursor.
    cursor: str = betterproto.string_field(2)
    # Max number of groups to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # Language tag filter
    lang_tag: str = betterproto.string_field(4)
    # Number of group members
    members: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT32)
    # Optional Open/Closed filter.
    open: Optional[bool] = betterproto.message_field(6, wraps=betterproto.TYPE_BOOL)


@dataclass
class GroupUsersRequest(betterproto.Message):
    """List all users that are part of a group."""

    # The group ID to list from.
    group_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # The group user state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(4)


@dataclass
class LeaderboardRecordsAroundOwnerRequest(betterproto.Message):
    """List leaerboard records from a given leaderboard around the owner."""

    # The ID of the tournament to list for.
    leaderboard_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_UINT32)
    # The owner to retrieve records around.
    owner_id: str = betterproto.string_field(3)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT64)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(5)


@dataclass
class LeaderboardRecordsRequest(betterproto.Message):
    """List leaderboard records from a given leaderboard."""

    # The ID of the leaderboard to list for.
    leaderboard_id: str = betterproto.string_field(1)
    # One or more owners to retrieve records for.
    owner_ids: List[str] = betterproto.string_field(2)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(4)
    # Expiry in seconds (since epoch) to begin fetching records from. Optional. 0
    # means from current time.
    expiry: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT64)


@dataclass
class MatchesRequest(betterproto.Message):
    """List realtime matches."""

    # Limit the number of returned matches.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # Authoritative or relayed matches.
    authoritative: Optional[bool] = betterproto.message_field(
        2, wraps=betterproto.TYPE_BOOL
    )
    # Label filter.
    label: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # Minimum user count.
    min_size: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT32)
    # Maximum user count.
    max_size: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT32)
    # Arbitrary label query.
    query: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)


@dataclass
class NotificationsRequest(betterproto.Message):
    """Get a list of unexpired notifications."""

    # The number of notifications to get. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # A cursor to page through notifications. May be cached by clients to get
    # from point in time forwards.
    cacheable_cursor: str = betterproto.string_field(2)


@dataclass
class StorageObjectsRequest(betterproto.Message):
    """List publicly readable storage objects in a given collection."""

    # ID of the user.
    user_id: str = betterproto.string_field(1)
    # The collection which stores the object.
    collection: str = betterproto.string_field(2)
    # The number of storage objects to list. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # The cursor to page through results from.
    cursor: str = betterproto.string_field(4)


@dataclass
class SubscriptionsRequest(betterproto.Message):
    """List user subscriptions."""

    # Max number of results per page
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # Cursor to retrieve a page of records from
    cursor: str = betterproto.string_field(2)


@dataclass
class TournamentRecordsAroundOwnerRequest(betterproto.Message):
    """List tournament records from a given tournament around the owner."""

    # The ID of the tournament to list for.
    tournament_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_UINT32)
    # The owner to retrieve records around.
    owner_id: str = betterproto.string_field(3)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT64)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(5)


@dataclass
class TournamentRecordsRequest(betterproto.Message):
    """List tournament records from a given tournament."""

    # The ID of the tournament to list for.
    tournament_id: str = betterproto.string_field(1)
    # One or more owners to retrieve records for.
    owner_ids: List[str] = betterproto.string_field(2)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(4)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT64)


@dataclass
class TournamentsRequest(betterproto.Message):
    """List active/upcoming tournaments based on given filters."""

    # The start of the categories to include. Defaults to 0.
    category_start: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    # The end of the categories to include. Defaults to 128.
    category_end: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    # The start time for tournaments. Defaults to epoch.
    start_time: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    # The end time for tournaments. Defaults to +1 year from current Unix time.
    end_time: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(6, wraps=betterproto.TYPE_INT32)
    # A next page cursor for listings (optional).
    cursor: str = betterproto.string_field(8)


@dataclass
class UserGroupsRequest(betterproto.Message):
    """List the groups a user is part of, and their relationship to each."""

    # ID of the user.
    user_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # The user group state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(4)


@dataclass
class Match(betterproto.Message):
    """Represents a realtime match."""

    # The ID of the match, can be used to join.
    match_id: str = betterproto.string_field(1)
    # True if it's an server-managed authoritative match, false otherwise.
    authoritative: bool = betterproto.bool_field(2)
    # Match label, if any.
    label: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # Current number of users in the match.
    size: int = betterproto.int32_field(4)
    # Tick Rate
    tick_rate: int = betterproto.int32_field(5)
    # Handler name
    handler_name: str = betterproto.string_field(6)


@dataclass
class MatchesResponse(betterproto.Message):
    """A list of realtime matches."""

    # A number of matches corresponding to a list operation.
    matches: List["Match"] = betterproto.message_field(1)


@dataclass
class Notification(betterproto.Message):
    """A notification in the server."""

    # ID of the Notification.
    id: str = betterproto.string_field(1)
    # Subject of the notification.
    subject: str = betterproto.string_field(2)
    # Content of the notification in JSON.
    content: str = betterproto.string_field(3)
    # Category code for this notification.
    code: int = betterproto.int32_field(4)
    # ID of the sender, if a user. Otherwise 'null'.
    sender_id: str = betterproto.string_field(5)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # notification was created.
    create_time: datetime = betterproto.message_field(6)
    # True if this notification was persisted to the database.
    persistent: bool = betterproto.bool_field(7)


@dataclass
class NotificationsResponse(betterproto.Message):
    """A collection of zero or more notifications."""

    # Collection of notifications.
    notifications: List["Notification"] = betterproto.message_field(1)
    # Use this cursor to paginate notifications. Cache this to catch up to new
    # notifications.
    cacheable_cursor: str = betterproto.string_field(2)


@dataclass
class PromoteGroupUsersRequest(betterproto.Message):
    """Promote a set of users in a group to the next role up."""

    # The group ID to promote in.
    group_id: str = betterproto.string_field(1)
    # The users to promote.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class DemoteGroupUsersRequest(betterproto.Message):
    """Demote a set of users in a group to the next role down."""

    # The group ID to demote in.
    group_id: str = betterproto.string_field(1)
    # The users to demote.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class ReadStorageObjectId(betterproto.Message):
    """Storage objects to get."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The user owner of the object.
    user_id: str = betterproto.string_field(3)


@dataclass
class ReadStorageObjectsRequest(betterproto.Message):
    """Batch get storage objects."""

    # Batch of storage objects.
    object_ids: List["ReadStorageObjectId"] = betterproto.message_field(1)


@dataclass
class RpcMsg(betterproto.Message):
    """Execute an Lua function on the server."""

    # The identifier of the function.
    id: str = betterproto.string_field(1)
    # The payload of the function which must be a JSON object.
    payload: str = betterproto.string_field(2)
    # The authentication key used when executed as a non-client HTTP request.
    http_key: str = betterproto.string_field(3)


@dataclass
class SessionResponse(betterproto.Message):
    """A user's session used to authenticate messages."""

    # True if the corresponding account was just created, false otherwise.
    created: bool = betterproto.bool_field(1)
    # Authentication credentials.
    token: str = betterproto.string_field(2)
    # Refresh token that can be used for session token renewal.
    refresh_token: str = betterproto.string_field(3)


@dataclass
class StorageObject(betterproto.Message):
    """An object within the storage engine."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The user owner of the object.
    user_id: str = betterproto.string_field(3)
    # The value of the object.
    value: str = betterproto.string_field(4)
    # The version hash of the object.
    version: str = betterproto.string_field(5)
    # The read access permissions for the object.
    permission_read: int = betterproto.int32_field(6)
    # The write access permissions for the object.
    permission_write: int = betterproto.int32_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # object was created.
    create_time: datetime = betterproto.message_field(8)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # object was last updated.
    update_time: datetime = betterproto.message_field(9)


@dataclass
class StorageObjectAck(betterproto.Message):
    """A storage acknowledgement."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The version hash of the object.
    version: str = betterproto.string_field(3)
    # The owner of the object.
    user_id: str = betterproto.string_field(4)


@dataclass
class WriteStorageObjectsResponse(betterproto.Message):
    """Batch of acknowledgements for the storage object write."""

    # Batch of storage write acknowledgements.
    acks: List["StorageObjectAck"] = betterproto.message_field(1)


@dataclass
class ReadStorageObjectsResponse(betterproto.Message):
    """Batch of storage objects."""

    # The batch of storage objects.
    objects: List["StorageObject"] = betterproto.message_field(1)


@dataclass
class StorageObjectsResponse(betterproto.Message):
    """List of storage objects."""

    # The list of storage objects.
    objects: List["StorageObject"] = betterproto.message_field(1)
    # The cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class Tournament(betterproto.Message):
    """A tournament on the server."""

    # The ID of the tournament.
    id: str = betterproto.string_field(1)
    # The title for the tournament.
    title: str = betterproto.string_field(2)
    # The description of the tournament. May be blank.
    description: str = betterproto.string_field(3)
    # The category of the tournament. e.g. "vip" could be category 1.
    category: int = betterproto.uint32_field(4)
    # ASC (0) or DESC (1) sort mode of scores in the tournament.
    sort_order: int = betterproto.uint32_field(5)
    # The current number of players in the tournament.
    size: int = betterproto.uint32_field(6)
    # The maximum number of players for the tournament.
    max_size: int = betterproto.uint32_field(7)
    # The maximum score updates allowed per player for the current tournament.
    max_num_score: int = betterproto.uint32_field(8)
    # True if the tournament is active and can enter. A computed value.
    can_enter: bool = betterproto.bool_field(9)
    # The UNIX time when the tournament stops being active until next reset. A
    # computed value.
    end_active: int = betterproto.uint32_field(10)
    # The UNIX time when the tournament is next playable. A computed value.
    next_reset: int = betterproto.uint32_field(11)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(12)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament was created.
    create_time: datetime = betterproto.message_field(13)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament will start.
    start_time: datetime = betterproto.message_field(14)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament will be stopped.
    end_time: datetime = betterproto.message_field(15)
    # Duration of the tournament in seconds.
    duration: int = betterproto.uint32_field(16)
    # The UNIX time when the tournament start being active. A computed value.
    start_active: int = betterproto.uint32_field(17)
    # The UNIX time when the tournament was last reset. A computed value.
    prev_reset: int = betterproto.uint32_field(18)
    # Operator.
    operator: "OpType" = betterproto.enum_field(19)
    # Whether the leaderboard was created authoritatively or not.
    authoritative: bool = betterproto.bool_field(20)


@dataclass
class TournamentsResponse(betterproto.Message):
    """A list of tournaments."""

    # The list of tournaments returned.
    tournaments: List["Tournament"] = betterproto.message_field(1)
    # A pagination cursor (optional).
    cursor: str = betterproto.string_field(2)


@dataclass
class TournamentRecordsResponse(betterproto.Message):
    """
    A set of tournament records which may be part of a tournament records page
    or a batch of individual records.
    """

    # A list of tournament records.
    records: List["LeaderboardRecord"] = betterproto.message_field(1)
    # A batched set of tournament records belonging to specified owners.
    owner_records: List["LeaderboardRecord"] = betterproto.message_field(2)
    # The cursor to send when retireving the next page (optional).
    next_cursor: str = betterproto.string_field(3)
    # The cursor to send when retrieving the previous page (optional).
    prev_cursor: str = betterproto.string_field(4)


@dataclass
class UpdateAccountRequest(betterproto.Message):
    """Update a user's account details."""

    # The username of the user's account.
    username: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    # The display name of the user.
    display_name: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    # A URL for an avatar image.
    avatar_url: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    # The location set by the user.
    location: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    # The timezone set by the user.
    timezone: Optional[str] = betterproto.message_field(
        6, wraps=betterproto.TYPE_STRING
    )


@dataclass
class UpdateGroupRequest(betterproto.Message):
    """Update fields in a given group."""

    # The ID of the group to update.
    group_id: str = betterproto.string_field(1)
    # Name.
    name: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # Description string.
    description: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # Lang tag.
    lang_tag: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    # Avatar URL.
    avatar_url: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    # Open is true if anyone should be allowed to join, or false if joins must be
    # approved by a group admin.
    open: Optional[bool] = betterproto.message_field(6, wraps=betterproto.TYPE_BOOL)


@dataclass
class User(betterproto.Message):
    """A user in the server."""

    # The id of the user's account.
    id: str = betterproto.string_field(1)
    # The username of the user's account.
    username: str = betterproto.string_field(2)
    # The display name of the user.
    display_name: str = betterproto.string_field(3)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(4)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(5)
    # The location set by the user.
    location: str = betterproto.string_field(6)
    # The timezone set by the user.
    timezone: str = betterproto.string_field(7)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(8)
    # The Facebook id in the user's account.
    facebook_id: str = betterproto.string_field(9)
    # The Google id in the user's account.
    google_id: str = betterproto.string_field(10)
    # The Apple Game Center in of the user's account.
    gamecenter_id: str = betterproto.string_field(11)
    # The Steam id in the user's account.
    steam_id: str = betterproto.string_field(12)
    # Indicates whether the user is currently online.
    online: bool = betterproto.bool_field(13)
    # Number of related edges to this user.
    edge_count: int = betterproto.int32_field(14)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user was created.
    create_time: datetime = betterproto.message_field(15)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user was last updated.
    update_time: datetime = betterproto.message_field(16)
    # The Facebook Instant Game ID in the user's account.
    facebook_instant_game_id: str = betterproto.string_field(17)
    # The Apple Sign In ID in the user's account.
    apple_id: str = betterproto.string_field(18)


@dataclass
class UserGroup(betterproto.Message):
    """A single group-role pair."""

    # Group.
    group: "Group" = betterproto.message_field(1)
    # The user's relationship to the group. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)


@dataclass
class UserGroupsResponse(betterproto.Message):
    """
    A list of groups belonging to a user, along with the user's role in each
    group.
    """

    # Group-role pairs for a user.
    user_groups: List["UserGroup"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class UsersResponse(betterproto.Message):
    """A collection of zero or more users."""

    # The User objects.
    users: List["User"] = betterproto.message_field(1)


@dataclass
class ValidatePurchaseAppleRequest(betterproto.Message):
    """Apple IAP Purchases validation request"""

    # Base64 encoded Apple receipt data payload.
    receipt: str = betterproto.string_field(1)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidateSubscriptionAppleRequest(betterproto.Message):
    """Apple Subscription validation request"""

    # Base64 encoded Apple receipt data payload.
    receipt: str = betterproto.string_field(1)
    # Persist the subscription.
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatePurchaseGoogleRequest(betterproto.Message):
    """Google IAP Purchase validation request"""

    # JSON encoded Google purchase payload.
    purchase: str = betterproto.string_field(1)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidateSubscriptionGoogleRequest(betterproto.Message):
    """Google Subscription validation request"""

    # JSON encoded Google purchase payload.
    receipt: str = betterproto.string_field(1)
    # Persist the subscription.
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatePurchaseHuaweiRequest(betterproto.Message):
    """Huawei IAP Purchase validation request"""

    # JSON encoded Huawei InAppPurchaseData.
    purchase: str = betterproto.string_field(1)
    # InAppPurchaseData signature.
    signature: str = betterproto.string_field(2)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatedPurchase(betterproto.Message):
    """Validated Purchase stored by Nakama."""

    # Purchase User ID.
    user_id: str = betterproto.string_field(1)
    # Purchase Product ID.
    product_id: str = betterproto.string_field(2)
    # Purchase Transaction ID.
    transaction_id: str = betterproto.string_field(3)
    # Store identifier
    store: "StoreProvider" = betterproto.enum_field(4)
    # Timestamp when the purchase was done.
    purchase_time: datetime = betterproto.message_field(5)
    # Timestamp when the receipt validation was stored in DB.
    create_time: datetime = betterproto.message_field(6)
    # Timestamp when the receipt validation was updated in DB.
    update_time: datetime = betterproto.message_field(7)
    # Timestamp when the purchase was refunded. Set to UNIX
    refund_time: datetime = betterproto.message_field(8)
    # Raw provider validation response.
    provider_response: str = betterproto.string_field(9)
    # Whether the purchase was done in production or sandbox environment.
    environment: "StoreEnvironment" = betterproto.enum_field(10)
    # Whether the purchase had already been validated by Nakama before.
    seen_before: bool = betterproto.bool_field(11)


@dataclass
class ValidatePurchaseResponse(betterproto.Message):
    """Validate IAP response."""

    # Newly seen validated purchases.
    validated_purchases: List["ValidatedPurchase"] = betterproto.message_field(1)


@dataclass
class ValidateSubscriptionResponse(betterproto.Message):
    """Validate Subscription response."""

    validated_subscription: "ValidatedSubscription" = betterproto.message_field(1)


@dataclass
class ValidatedSubscription(betterproto.Message):
    # Subscription User ID.
    user_id: str = betterproto.string_field(1)
    # Purchase Product ID.
    product_id: str = betterproto.string_field(2)
    # Purchase Original transaction ID (we only keep track of the original
    # subscription, not subsequent renewals).
    original_transaction_id: str = betterproto.string_field(3)
    # Store identifier
    store: "StoreProvider" = betterproto.enum_field(4)
    # UNIX Timestamp when the purchase was done.
    purchase_time: datetime = betterproto.message_field(5)
    # UNIX Timestamp when the receipt validation was stored in DB.
    create_time: datetime = betterproto.message_field(6)
    # UNIX Timestamp when the receipt validation was updated in DB.
    update_time: datetime = betterproto.message_field(7)
    # Whether the purchase was done in production or sandbox environment.
    environment: "StoreEnvironment" = betterproto.enum_field(8)
    # Subscription expiration time. The subscription can still be auto-renewed to
    # extend the expiration time further.
    expiry_time: datetime = betterproto.message_field(9)
    # Subscription refund time. If this time is set, the subscription was
    # refunded.
    refund_time: datetime = betterproto.message_field(10)
    # Raw provider validation response body.
    provider_response: str = betterproto.string_field(11)
    # Raw provider notification body.
    provider_notification: str = betterproto.string_field(12)
    # Whether the subscription is currently active or not.
    active: bool = betterproto.bool_field(13)


@dataclass
class PurchasesResponse(betterproto.Message):
    """A list of validated purchases stored by Nakama."""

    # Stored validated purchases.
    validated_purchases: List["ValidatedPurchase"] = betterproto.message_field(1)
    # The cursor to send when retrieving the next page, if any.
    cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)


@dataclass
class SubscriptionsResponse(betterproto.Message):
    """A list of validated subscriptions stored by Nakama."""

    # Stored validated subscriptions.
    validated_subscriptions: List["ValidatedSubscription"] = betterproto.message_field(
        1
    )
    # The cursor to send when retrieving the next page, if any.
    cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)


@dataclass
class LeaderboardRecordWrite(betterproto.Message):
    """Record values to write."""

    # The score value to submit.
    score: int = betterproto.int64_field(1)
    # An optional secondary value.
    subscore: int = betterproto.int64_field(2)
    # Optional record metadata.
    metadata: str = betterproto.string_field(3)
    # Operator override.
    operator: "OpType" = betterproto.enum_field(4)


@dataclass
class WriteLeaderboardRecordRequest(betterproto.Message):
    """A request to submit a score to a leaderboard."""

    # The ID of the leaderboard to write to.
    leaderboard_id: str = betterproto.string_field(1)
    # Record input.
    record: "LeaderboardRecordWrite" = betterproto.message_field(2)


@dataclass
class WriteStorageObject(betterproto.Message):
    """The object to store."""

    # The collection to store the object.
    collection: str = betterproto.string_field(1)
    # The key for the object within the collection.
    key: str = betterproto.string_field(2)
    # The value of the object.
    value: str = betterproto.string_field(3)
    # The version hash of the object to check. Possible values are: ["", "*",
    # "#hash#"].
    version: str = betterproto.string_field(4)
    # The read access permissions for the object.
    permission_read: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_INT32
    )
    # The write access permissions for the object.
    permission_write: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_INT32
    )


@dataclass
class WriteStorageObjectsRequest(betterproto.Message):
    """Write objects to the storage engine."""

    # The objects to store on the server.
    objects: List["WriteStorageObject"] = betterproto.message_field(1)


@dataclass
class TournamentRecordWrite(betterproto.Message):
    """Record values to write."""

    # The score value to submit.
    score: int = betterproto.int64_field(1)
    # An optional secondary value.
    subscore: int = betterproto.int64_field(2)
    # A JSON object of additional properties (optional).
    metadata: str = betterproto.string_field(3)
    # Operator override.
    operator: "OpType" = betterproto.enum_field(4)


@dataclass
class WriteTournamentRecordRequest(betterproto.Message):
    """A request to submit a score to a tournament."""

    # The tournament ID to write the record for.
    tournament_id: str = betterproto.string_field(1)
    # Record input.
    record: "TournamentRecordWrite" = betterproto.message_field(2)
