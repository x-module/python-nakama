# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: nakama.proto, realtime.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

import betterproto


class FriendState(betterproto.Enum):
    """The friendship status."""

    # The user is a friend of the current user.
    FRIEND = 0
    # The current user has sent an invite to the user.
    INVITE_SENT = 1
    # The current user has received an invite from this user.
    INVITE_RECEIVED = 2
    # The current user has blocked this user.
    BLOCKED = 3


class UserRoleState(betterproto.Enum):
    """The group role status."""

    # The user is a superadmin with full control of the group.
    SUPERADMIN = 0
    # The user is an admin with additional privileges.
    ADMIN = 1
    # The user is a regular member.
    MEMBER = 2
    # The user has requested to join the group
    JOIN_REQUEST = 3


class StoreProvider(betterproto.Enum):
    """Validation Provider,"""

    # Apple App Store
    APPLE_APP_STORE = 0
    # Google Play Store
    GOOGLE_PLAY_STORE = 1
    # Huawei App Gallery
    HUAWEI_APP_GALLERY = 2


class StoreEnvironment(betterproto.Enum):
    """Environment where a purchase/subscription took place,"""

    # Unknown environment.
    UNKNOWN = 0
    # Sandbox/test environment.
    SANDBOX = 1
    # Production environment.
    PRODUCTION = 2


class OpType(betterproto.Enum):
    """
    Operator that can be used to override the one set in the leaderboard.
    """

    # Do not override the leaderboard operator.
    NO_OVERRIDE = 0
    # Override the leaderboard operator with BEST.
    BEST = 1
    # Override the leaderboard operator with SET.
    SET = 2
    # Override the leaderboard operator with INCREMENT.
    INCREMENT = 3
    # Override the leaderboard operator with DECREMENT.
    DECREMENT = 4


class ChannelType(betterproto.Enum):
    """The type of chat channel."""

    # Default case. Assumed as ROOM type.
    TYPE_UNSPECIFIED = 0
    # A room which anyone can join to chat.
    ROOM = 1
    # A private channel for 1-on-1 chat.
    DIRECT_MESSAGE = 2
    # A channel for group chat.
    GROUP = 3


class ErrorCode(betterproto.Enum):
    """The selection of possible error codes."""

    # An unexpected result from the server.
    RUNTIME_EXCEPTION = 0
    # The server received a message which is not recognised.
    UNRECOGNIZED_PAYLOAD = 1
    # A message was expected but contains no content.
    MISSING_PAYLOAD = 2
    # Fields in the message have an invalid format.
    BAD_INPUT = 3
    # The match id was not found.
    MATCH_NOT_FOUND = 4
    # The match join was rejected.
    MATCH_JOIN_REJECTED = 5
    # The runtime function does not exist on the server.
    RUNTIME_FUNCTION_NOT_FOUND = 6
    # The runtime function executed with an error.
    RUNTIME_FUNCTION_EXCEPTION = 7


@dataclass
class HealthcheckRequest(betterproto.Message):
    """Healthcheck request."""

    pass


@dataclass
class AccountRequest(betterproto.Message):
    """Account request."""

    pass


@dataclass
class AccountResponse(betterproto.Message):
    """A user with additional account details. Always the current user."""

    # The user object.
    user: "User" = betterproto.message_field(1)
    # The user's wallet data.
    wallet: str = betterproto.string_field(2)
    # The email address of the user.
    email: str = betterproto.string_field(3)
    # The devices which belong to the user's account.
    devices: List["AccountDevice"] = betterproto.message_field(4)
    # The custom id in the user's account.
    custom_id: str = betterproto.string_field(5)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user's email was verified.
    verify_time: datetime = betterproto.message_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user's account was disabled/banned.
    disable_time: datetime = betterproto.message_field(7)


@dataclass
class AccountRefresh(betterproto.Message):
    """Obtain a new authentication token using a refresh token."""

    # Refresh token.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountApple(betterproto.Message):
    """
    Send a Apple Sign In token to the server. Used with
    authenticate/link/unlink.
    """

    # The ID token received from Apple to validate.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountCustom(betterproto.Message):
    """Send a custom ID to the server. Used with authenticate/link/unlink."""

    # A custom identifier.
    id: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountDevice(betterproto.Message):
    """
    Send a device to the server. Used with authenticate/link/unlink and user.
    """

    # A device identifier. Should be obtained by a platform-specific device API.
    id: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountEmail(betterproto.Message):
    """
    Send an email with password to the server. Used with
    authenticate/link/unlink.
    """

    # A valid RFC-5322 email address.
    email: str = betterproto.string_field(1)
    # A password for the user account.
    password: str = betterproto.string_field(2)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountFacebook(betterproto.Message):
    """
    Send a Facebook token to the server. Used with authenticate/link/unlink.
    """

    # The OAuth token received from Facebook to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountFacebookInstantGame(betterproto.Message):
    """
    Send a Facebook Instant Game token to the server. Used with
    authenticate/link/unlink.
    """

    # The OAuth token received from a Facebook Instant Game that may be decoded
    # with the Application Secret (must be available with the nakama
    # configuration)
    signed_player_info: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountGameCenter(betterproto.Message):
    """
    Send Apple's Game Center account credentials to the server. Used with
    authenticate/link/unlink.
    """

    # Player ID (generated by GameCenter).
    player_id: str = betterproto.string_field(1)
    # Bundle ID (generated by GameCenter).
    bundle_id: str = betterproto.string_field(2)
    # Time since UNIX epoch when the signature was created.
    timestamp_seconds: int = betterproto.int64_field(3)
    # A random "NSString" used to compute the hash and keep it randomized.
    salt: str = betterproto.string_field(4)
    # The verification signature data generated.
    signature: str = betterproto.string_field(5)
    # The URL for the public encryption key.
    public_key_url: str = betterproto.string_field(6)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        7, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountGoogle(betterproto.Message):
    """
    Send a Google token to the server. Used with authenticate/link/unlink.
    """

    # The OAuth token received from Google to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AccountSteam(betterproto.Message):
    """
    Send a Steam token to the server. Used with authenticate/link/unlink.
    """

    # The account token received from Steam to access their profile API.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class AddFriendsRequest(betterproto.Message):
    """Add one or more friends to the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class AddGroupUsersRequest(betterproto.Message):
    """Add users to a group."""

    # The group to add users to.
    group_id: str = betterproto.string_field(1)
    # The users to add.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class SessionRefreshRequest(betterproto.Message):
    """Authenticate against the server with a refresh token."""

    # Refresh token.
    token: str = betterproto.string_field(1)
    # Extra information that will be bundled in the session token.
    vars: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class SessionLogoutRequest(betterproto.Message):
    """
    Log out a session, invalidate a refresh token, or log out all
    sessions/refresh tokens for a user.
    """

    # Session token to log out.
    token: str = betterproto.string_field(1)
    # Refresh token to invalidate.
    refresh_token: str = betterproto.string_field(2)


@dataclass
class AuthenticateAppleRequest(betterproto.Message):
    """Authenticate against the server with Apple Sign In."""

    # The Apple account details.
    account: "AccountApple" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateCustomRequest(betterproto.Message):
    """Authenticate against the server with a custom ID."""

    # The custom account details.
    account: "AccountCustom" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateDeviceRequest(betterproto.Message):
    """Authenticate against the server with a device ID."""

    # The device account details.
    account: "AccountDevice" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateEmailRequest(betterproto.Message):
    """Authenticate against the server with email+password."""

    # The email account details.
    account: "AccountEmail" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateFacebookRequest(betterproto.Message):
    """Authenticate against the server with Facebook."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)
    # Import Facebook friends for the user.
    sync: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)


@dataclass
class AuthenticateFacebookInstantGameRequest(betterproto.Message):
    """Authenticate against the server with Facebook Instant Game token."""

    # The Facebook Instant Game account details.
    account: "AccountFacebookInstantGame" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateGameCenterRequest(betterproto.Message):
    """Authenticate against the server with Apple's Game Center."""

    # The Game Center account details.
    account: "AccountGameCenter" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateGoogleRequest(betterproto.Message):
    """Authenticate against the server with Google."""

    # The Google account details.
    account: "AccountGoogle" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)


@dataclass
class AuthenticateSteamRequest(betterproto.Message):
    """Authenticate against the server with Steam."""

    # The Steam account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Register the account if the user does not already exist.
    create: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    # Set the username on the account at register. Must be unique.
    username: str = betterproto.string_field(3)
    # Import Steam friends for the user.
    sync: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)


@dataclass
class BanGroupUsersRequest(betterproto.Message):
    """Ban users from a group."""

    # The group to ban users from.
    group_id: str = betterproto.string_field(1)
    # The users to ban.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class BlockFriendsRequest(betterproto.Message):
    """Block one or more friends for the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class ChannelMessage(betterproto.Message):
    """A message sent on a channel."""

    # The channel this message belongs to.
    channel_id: str = betterproto.string_field(1)
    # The unique ID of this message.
    message_id: str = betterproto.string_field(2)
    # The code representing a message type or category.
    code: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # Message sender, usually a user ID.
    sender_id: str = betterproto.string_field(4)
    # The username of the message sender, if any.
    username: str = betterproto.string_field(5)
    # The content payload.
    content: str = betterproto.string_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was created.
    create_time: datetime = betterproto.message_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was last updated.
    update_time: datetime = betterproto.message_field(8)
    # True if the message was persisted to the channel's history, false
    # otherwise.
    persistent: Optional[bool] = betterproto.message_field(
        9, wraps=betterproto.TYPE_BOOL
    )
    # The name of the chat room, or an empty string if this message was not sent
    # through a chat room.
    room_name: str = betterproto.string_field(10)
    # The ID of the group, or an empty string if this message was not sent
    # through a group channel.
    group_id: str = betterproto.string_field(11)
    # The ID of the first DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_one: str = betterproto.string_field(12)
    # The ID of the second DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_two: str = betterproto.string_field(13)


@dataclass
class ChannelMessagesResponse(betterproto.Message):
    """A list of channel messages, usually a result of a list operation."""

    # A list of messages.
    messages: List["ChannelMessage"] = betterproto.message_field(1)
    # The cursor to send when retrieving the next page, if any.
    next_cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)
    # Cacheable cursor to list newer messages. Durable and designed to be stored,
    # unlike next/prev cursors.
    cacheable_cursor: str = betterproto.string_field(4)


@dataclass
class CreateGroupRequest(betterproto.Message):
    """Create a group with the current user as owner."""

    # A unique name for the group.
    name: str = betterproto.string_field(1)
    # A description for the group.
    description: str = betterproto.string_field(2)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(3)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(4)
    # Mark a group as open or not where only admins can accept members.
    open: bool = betterproto.bool_field(5)
    # Maximum number of group members.
    max_count: int = betterproto.int32_field(6)


@dataclass
class DeleteFriendsRequest(betterproto.Message):
    """Delete one or more friends for the current user."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class DeleteGroupRequest(betterproto.Message):
    """Delete a group the user has access to."""

    # The id of a group.
    group_id: str = betterproto.string_field(1)


@dataclass
class DeleteLeaderboardRecordRequest(betterproto.Message):
    """Delete a leaderboard record."""

    # The leaderboard ID to delete from.
    leaderboard_id: str = betterproto.string_field(1)


@dataclass
class DeleteNotificationsRequest(betterproto.Message):
    """Delete one or more notifications for the current user."""

    # The id of notifications.
    ids: List[str] = betterproto.string_field(1)


@dataclass
class DeleteTournamentRecordRequest(betterproto.Message):
    """Delete a leaderboard record."""

    # The tournament ID to delete from.
    tournament_id: str = betterproto.string_field(1)


@dataclass
class DeleteStorageObjectId(betterproto.Message):
    """Storage objects to delete."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The version hash of the object.
    version: str = betterproto.string_field(3)


@dataclass
class DeleteStorageObjectsRequest(betterproto.Message):
    """Batch delete storage objects."""

    # Batch of storage objects.
    object_ids: List["DeleteStorageObjectId"] = betterproto.message_field(1)


@dataclass
class EventRequest(betterproto.Message):
    """
    Represents an event to be passed through the server to registered event
    handlers.
    """

    # An event name, type, category, or identifier.
    name: str = betterproto.string_field(1)
    # Arbitrary event property values.
    properties: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # The time when the event was triggered.
    timestamp: datetime = betterproto.message_field(3)
    # True if the event came directly from a client call, false otherwise.
    external: bool = betterproto.bool_field(4)


@dataclass
class Friend(betterproto.Message):
    """A friend of a user."""

    # The user object.
    user: "User" = betterproto.message_field(1)
    # The friend status. -- use enum FriendState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # Time of the latest relationship update.
    update_time: datetime = betterproto.message_field(3)


@dataclass
class FriendsResponse(betterproto.Message):
    """A collection of zero or more friends of the user."""

    # The Friend objects.
    friends: List["Friend"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class UsersRequest(betterproto.Message):
    """Fetch a batch of zero or more users from the server."""

    # The account id of a user.
    ids: List[str] = betterproto.string_field(1)
    # The account username of a user.
    usernames: List[str] = betterproto.string_field(2)
    # The Facebook ID of a user.
    facebook_ids: List[str] = betterproto.string_field(3)


@dataclass
class SubscriptionRequest(betterproto.Message):
    """Fetch a subscription by product id."""

    # Product id of the subscription
    product_id: str = betterproto.string_field(1)


@dataclass
class Group(betterproto.Message):
    """A group in the server."""

    # The id of a group.
    id: str = betterproto.string_field(1)
    # The id of the user who created the group.
    creator_id: str = betterproto.string_field(2)
    # The unique name of the group.
    name: str = betterproto.string_field(3)
    # A description for the group.
    description: str = betterproto.string_field(4)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(5)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(6)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(7)
    # Anyone can join open groups, otherwise only admins can accept members.
    open: Optional[bool] = betterproto.message_field(8, wraps=betterproto.TYPE_BOOL)
    # The current count of all members in the group.
    edge_count: int = betterproto.int32_field(9)
    # The maximum number of members allowed.
    max_count: int = betterproto.int32_field(10)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # group was created.
    create_time: datetime = betterproto.message_field(11)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # group was last updated.
    update_time: datetime = betterproto.message_field(12)


@dataclass
class GroupsResponse(betterproto.Message):
    """One or more groups returned from a listing operation."""

    # One or more groups.
    groups: List["Group"] = betterproto.message_field(1)
    # A cursor used to get the next page.
    cursor: str = betterproto.string_field(2)


@dataclass
class GroupUser(betterproto.Message):
    """A single user-role pair."""

    # User.
    user: "User" = betterproto.message_field(1)
    # Their relationship to the group. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)


@dataclass
class GroupUsersResponse(betterproto.Message):
    """A list of users belonging to a group, along with their role."""

    # User-role pairs for a group.
    group_users: List["GroupUser"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class ImportFacebookFriendsRequest(betterproto.Message):
    """Import Facebook friends into the current user's account."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Reset the current user's friends list.
    reset: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ImportSteamFriendsRequest(betterproto.Message):
    """Import Facebook friends into the current user's account."""

    # The Facebook account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Reset the current user's friends list.
    reset: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class JoinGroupRequest(betterproto.Message):
    """Immediately join an open group, or request to join a closed one."""

    # The group ID to join. The group must already exist.
    group_id: str = betterproto.string_field(1)


@dataclass
class JoinTournamentRequest(betterproto.Message):
    """The request to join a tournament."""

    # The ID of the tournament to join. The tournament must already exist.
    tournament_id: str = betterproto.string_field(1)


@dataclass
class KickGroupUsersRequest(betterproto.Message):
    """Kick a set of users from a group."""

    # The group ID to kick from.
    group_id: str = betterproto.string_field(1)
    # The users to kick.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class Leaderboard(betterproto.Message):
    """A leaderboard on the server."""

    # The ID of the leaderboard.
    id: str = betterproto.string_field(1)
    # ASC(0) or DESC(1) sort mode of scores in the leaderboard.
    sort_order: int = betterproto.uint32_field(2)
    # BEST, SET, INCREMENT or DECREMENT operator mode of the leaderboard.
    operator: "OpType" = betterproto.enum_field(3)
    # The UNIX time when the leaderboard was previously reset. A computed value.
    prev_reset: int = betterproto.uint32_field(4)
    # The UNIX time when the leaderboard is next playable. A computed value.
    next_reset: int = betterproto.uint32_field(5)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(6)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard was created.
    create_time: datetime = betterproto.message_field(7)
    # Whether the leaderboard was created authoritatively or not.
    authoritative: bool = betterproto.bool_field(8)


@dataclass
class LeaderboardsResponse(betterproto.Message):
    """A list of leaderboards"""

    # The list of leaderboards returned.
    leaderboards: List["Leaderboard"] = betterproto.message_field(1)
    # A pagination cursor (optional).
    cursor: str = betterproto.string_field(2)


@dataclass
class LeaderboardRecord(betterproto.Message):
    """
    Represents a complete leaderboard record with all scores and associated
    metadata.
    """

    # The ID of the leaderboard this score belongs to.
    leaderboard_id: str = betterproto.string_field(1)
    # The ID of the score owner, usually a user or group.
    owner_id: str = betterproto.string_field(2)
    # The username of the score owner, if the owner is a user.
    username: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # The score value.
    score: int = betterproto.int64_field(4)
    # An optional subscore value.
    subscore: int = betterproto.int64_field(5)
    # The number of submissions to this score record.
    num_score: int = betterproto.int32_field(6)
    # Metadata.
    metadata: str = betterproto.string_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record was created.
    create_time: datetime = betterproto.message_field(8)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record was updated.
    update_time: datetime = betterproto.message_field(9)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # leaderboard record expires.
    expiry_time: datetime = betterproto.message_field(10)
    # The rank of this record.
    rank: int = betterproto.int64_field(11)
    # The maximum number of score updates allowed by the owner.
    max_num_score: int = betterproto.uint32_field(12)


@dataclass
class LeaderboardRecordsResponse(betterproto.Message):
    """
    A set of leaderboard records, may be part of a leaderboard records page or
    a batch of individual records.
    """

    # A list of leaderboard records.
    records: List["LeaderboardRecord"] = betterproto.message_field(1)
    # A batched set of leaderboard records belonging to specified owners.
    owner_records: List["LeaderboardRecord"] = betterproto.message_field(2)
    # The cursor to send when retrieving the next page, if any.
    next_cursor: str = betterproto.string_field(3)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(4)


@dataclass
class LeaveGroupRequest(betterproto.Message):
    """Leave a group."""

    # The group ID to leave.
    group_id: str = betterproto.string_field(1)


@dataclass
class LinkFacebookRequest(betterproto.Message):
    """Link Facebook to the current user's account."""

    # The Facebook account details.
    account: "AccountFacebook" = betterproto.message_field(1)
    # Import Facebook friends for the user.
    sync: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class LinkSteamRequest(betterproto.Message):
    """Link Steam to the current user's account."""

    # The Facebook account details.
    account: "AccountSteam" = betterproto.message_field(1)
    # Import Steam friends for the user.
    sync: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ChannelMessagesRequest(betterproto.Message):
    """List a channel's message history."""

    # The channel ID to list from.
    channel_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # True if listing should be older messages to newer, false if reverse.
    forward: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)
    # A pagination cursor, if any.
    cursor: str = betterproto.string_field(4)


@dataclass
class FriendsRequest(betterproto.Message):
    """List friends for a user."""

    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # The friend state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(3)


@dataclass
class GroupsRequest(betterproto.Message):
    """List groups based on given filters."""

    # List groups that contain this value in their names.
    name: str = betterproto.string_field(1)
    # Optional pagination cursor.
    cursor: str = betterproto.string_field(2)
    # Max number of groups to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # Language tag filter
    lang_tag: str = betterproto.string_field(4)
    # Number of group members
    members: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT32)
    # Optional Open/Closed filter.
    open: Optional[bool] = betterproto.message_field(6, wraps=betterproto.TYPE_BOOL)


@dataclass
class GroupUsersRequest(betterproto.Message):
    """List all users that are part of a group."""

    # The group ID to list from.
    group_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # The group user state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(4)


@dataclass
class LeaderboardRecordsAroundOwnerRequest(betterproto.Message):
    """List leaerboard records from a given leaderboard around the owner."""

    # The ID of the tournament to list for.
    leaderboard_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_UINT32)
    # The owner to retrieve records around.
    owner_id: str = betterproto.string_field(3)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT64)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(5)


@dataclass
class LeaderboardRecordsRequest(betterproto.Message):
    """List leaderboard records from a given leaderboard."""

    # The ID of the leaderboard to list for.
    leaderboard_id: str = betterproto.string_field(1)
    # One or more owners to retrieve records for.
    owner_ids: List[str] = betterproto.string_field(2)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(4)
    # Expiry in seconds (since epoch) to begin fetching records from. Optional. 0
    # means from current time.
    expiry: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT64)


@dataclass
class MatchesRequest(betterproto.Message):
    """List realtime matches."""

    # Limit the number of returned matches.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # Authoritative or relayed matches.
    authoritative: Optional[bool] = betterproto.message_field(
        2, wraps=betterproto.TYPE_BOOL
    )
    # Label filter.
    label: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # Minimum user count.
    min_size: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT32)
    # Maximum user count.
    max_size: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT32)
    # Arbitrary label query.
    query: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)


@dataclass
class NotificationsRequest(betterproto.Message):
    """Get a list of unexpired notifications."""

    # The number of notifications to get. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # A cursor to page through notifications. May be cached by clients to get
    # from point in time forwards.
    cacheable_cursor: str = betterproto.string_field(2)


@dataclass
class StorageObjectsRequest(betterproto.Message):
    """List publicly readable storage objects in a given collection."""

    # ID of the user.
    user_id: str = betterproto.string_field(1)
    # The collection which stores the object.
    collection: str = betterproto.string_field(2)
    # The number of storage objects to list. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # The cursor to page through results from.
    cursor: str = betterproto.string_field(4)


@dataclass
class SubscriptionsRequest(betterproto.Message):
    """List user subscriptions."""

    # Max number of results per page
    limit: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    # Cursor to retrieve a page of records from
    cursor: str = betterproto.string_field(2)


@dataclass
class TournamentRecordsAroundOwnerRequest(betterproto.Message):
    """List tournament records from a given tournament around the owner."""

    # The ID of the tournament to list for.
    tournament_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_UINT32)
    # The owner to retrieve records around.
    owner_id: str = betterproto.string_field(3)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT64)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(5)


@dataclass
class TournamentRecordsRequest(betterproto.Message):
    """List tournament records from a given tournament."""

    # The ID of the tournament to list for.
    tournament_id: str = betterproto.string_field(1)
    # One or more owners to retrieve records for.
    owner_ids: List[str] = betterproto.string_field(2)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # A next or previous page cursor.
    cursor: str = betterproto.string_field(4)
    # Expiry in seconds (since epoch) to begin fetching records from.
    expiry: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_INT64)


@dataclass
class TournamentsRequest(betterproto.Message):
    """List active/upcoming tournaments based on given filters."""

    # The start of the categories to include. Defaults to 0.
    category_start: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    # The end of the categories to include. Defaults to 128.
    category_end: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    # The start time for tournaments. Defaults to epoch.
    start_time: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    # The end time for tournaments. Defaults to +1 year from current Unix time.
    end_time: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(6, wraps=betterproto.TYPE_INT32)
    # A next page cursor for listings (optional).
    cursor: str = betterproto.string_field(8)


@dataclass
class UserGroupsRequest(betterproto.Message):
    """List the groups a user is part of, and their relationship to each."""

    # ID of the user.
    user_id: str = betterproto.string_field(1)
    # Max number of records to return. Between 1 and 100.
    limit: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    # The user group state to list. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # An optional next page cursor.
    cursor: str = betterproto.string_field(4)


@dataclass
class Match(betterproto.Message):
    """Represents a realtime match."""

    # The ID of the match, can be used to join.
    match_id: str = betterproto.string_field(1)
    # True if it's an server-managed authoritative match, false otherwise.
    authoritative: bool = betterproto.bool_field(2)
    # Match label, if any.
    label: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # Current number of users in the match.
    size: int = betterproto.int32_field(4)
    # Tick Rate
    tick_rate: int = betterproto.int32_field(5)
    # Handler name
    handler_name: str = betterproto.string_field(6)


@dataclass
class MatchesResponse(betterproto.Message):
    """A list of realtime matches."""

    # A number of matches corresponding to a list operation.
    matches: List["Match"] = betterproto.message_field(1)


@dataclass
class Notification(betterproto.Message):
    """A notification in the server."""

    # ID of the Notification.
    id: str = betterproto.string_field(1)
    # Subject of the notification.
    subject: str = betterproto.string_field(2)
    # Content of the notification in JSON.
    content: str = betterproto.string_field(3)
    # Category code for this notification.
    code: int = betterproto.int32_field(4)
    # ID of the sender, if a user. Otherwise 'null'.
    sender_id: str = betterproto.string_field(5)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # notification was created.
    create_time: datetime = betterproto.message_field(6)
    # True if this notification was persisted to the database.
    persistent: bool = betterproto.bool_field(7)


@dataclass
class NotificationsResponse(betterproto.Message):
    """A collection of zero or more notifications."""

    # Collection of notifications.
    notifications: List["Notification"] = betterproto.message_field(1)
    # Use this cursor to paginate notifications. Cache this to catch up to new
    # notifications.
    cacheable_cursor: str = betterproto.string_field(2)


@dataclass
class PromoteGroupUsersRequest(betterproto.Message):
    """Promote a set of users in a group to the next role up."""

    # The group ID to promote in.
    group_id: str = betterproto.string_field(1)
    # The users to promote.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class DemoteGroupUsersRequest(betterproto.Message):
    """Demote a set of users in a group to the next role down."""

    # The group ID to demote in.
    group_id: str = betterproto.string_field(1)
    # The users to demote.
    user_ids: List[str] = betterproto.string_field(2)


@dataclass
class ReadStorageObjectId(betterproto.Message):
    """Storage objects to get."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The user owner of the object.
    user_id: str = betterproto.string_field(3)


@dataclass
class ReadStorageObjectsRequest(betterproto.Message):
    """Batch get storage objects."""

    # Batch of storage objects.
    object_ids: List["ReadStorageObjectId"] = betterproto.message_field(1)


@dataclass
class RpcMsg(betterproto.Message):
    """Execute an Lua function on the server."""

    # The identifier of the function.
    id: str = betterproto.string_field(1)
    # The payload of the function which must be a JSON object.
    payload: str = betterproto.string_field(2)
    # The authentication key used when executed as a non-client HTTP request.
    http_key: str = betterproto.string_field(3)


@dataclass
class SessionResponse(betterproto.Message):
    """A user's session used to authenticate messages."""

    # True if the corresponding account was just created, false otherwise.
    created: bool = betterproto.bool_field(1)
    # Authentication credentials.
    token: str = betterproto.string_field(2)
    # Refresh token that can be used for session token renewal.
    refresh_token: str = betterproto.string_field(3)


@dataclass
class StorageObject(betterproto.Message):
    """An object within the storage engine."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The user owner of the object.
    user_id: str = betterproto.string_field(3)
    # The value of the object.
    value: str = betterproto.string_field(4)
    # The version hash of the object.
    version: str = betterproto.string_field(5)
    # The read access permissions for the object.
    permission_read: int = betterproto.int32_field(6)
    # The write access permissions for the object.
    permission_write: int = betterproto.int32_field(7)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # object was created.
    create_time: datetime = betterproto.message_field(8)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # object was last updated.
    update_time: datetime = betterproto.message_field(9)


@dataclass
class StorageObjectAck(betterproto.Message):
    """A storage acknowledgement."""

    # The collection which stores the object.
    collection: str = betterproto.string_field(1)
    # The key of the object within the collection.
    key: str = betterproto.string_field(2)
    # The version hash of the object.
    version: str = betterproto.string_field(3)
    # The owner of the object.
    user_id: str = betterproto.string_field(4)


@dataclass
class WriteStorageObjectsResponse(betterproto.Message):
    """Batch of acknowledgements for the storage object write."""

    # Batch of storage write acknowledgements.
    acks: List["StorageObjectAck"] = betterproto.message_field(1)


@dataclass
class ReadStorageObjectsResponse(betterproto.Message):
    """Batch of storage objects."""

    # The batch of storage objects.
    objects: List["StorageObject"] = betterproto.message_field(1)


@dataclass
class StorageObjectsResponse(betterproto.Message):
    """List of storage objects."""

    # The list of storage objects.
    objects: List["StorageObject"] = betterproto.message_field(1)
    # The cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class Tournament(betterproto.Message):
    """A tournament on the server."""

    # The ID of the tournament.
    id: str = betterproto.string_field(1)
    # The title for the tournament.
    title: str = betterproto.string_field(2)
    # The description of the tournament. May be blank.
    description: str = betterproto.string_field(3)
    # The category of the tournament. e.g. "vip" could be category 1.
    category: int = betterproto.uint32_field(4)
    # ASC (0) or DESC (1) sort mode of scores in the tournament.
    sort_order: int = betterproto.uint32_field(5)
    # The current number of players in the tournament.
    size: int = betterproto.uint32_field(6)
    # The maximum number of players for the tournament.
    max_size: int = betterproto.uint32_field(7)
    # The maximum score updates allowed per player for the current tournament.
    max_num_score: int = betterproto.uint32_field(8)
    # True if the tournament is active and can enter. A computed value.
    can_enter: bool = betterproto.bool_field(9)
    # The UNIX time when the tournament stops being active until next reset. A
    # computed value.
    end_active: int = betterproto.uint32_field(10)
    # The UNIX time when the tournament is next playable. A computed value.
    next_reset: int = betterproto.uint32_field(11)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(12)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament was created.
    create_time: datetime = betterproto.message_field(13)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament will start.
    start_time: datetime = betterproto.message_field(14)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # tournament will be stopped.
    end_time: datetime = betterproto.message_field(15)
    # Duration of the tournament in seconds.
    duration: int = betterproto.uint32_field(16)
    # The UNIX time when the tournament start being active. A computed value.
    start_active: int = betterproto.uint32_field(17)
    # The UNIX time when the tournament was last reset. A computed value.
    prev_reset: int = betterproto.uint32_field(18)
    # Operator.
    operator: "OpType" = betterproto.enum_field(19)
    # Whether the leaderboard was created authoritatively or not.
    authoritative: bool = betterproto.bool_field(20)


@dataclass
class TournamentsResponse(betterproto.Message):
    """A list of tournaments."""

    # The list of tournaments returned.
    tournaments: List["Tournament"] = betterproto.message_field(1)
    # A pagination cursor (optional).
    cursor: str = betterproto.string_field(2)


@dataclass
class TournamentRecordsResponse(betterproto.Message):
    """
    A set of tournament records which may be part of a tournament records page
    or a batch of individual records.
    """

    # A list of tournament records.
    records: List["LeaderboardRecord"] = betterproto.message_field(1)
    # A batched set of tournament records belonging to specified owners.
    owner_records: List["LeaderboardRecord"] = betterproto.message_field(2)
    # The cursor to send when retireving the next page (optional).
    next_cursor: str = betterproto.string_field(3)
    # The cursor to send when retrieving the previous page (optional).
    prev_cursor: str = betterproto.string_field(4)


@dataclass
class UpdateAccountRequest(betterproto.Message):
    """Update a user's account details."""

    # The username of the user's account.
    username: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    # The display name of the user.
    display_name: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    # A URL for an avatar image.
    avatar_url: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    # The location set by the user.
    location: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    # The timezone set by the user.
    timezone: Optional[str] = betterproto.message_field(
        6, wraps=betterproto.TYPE_STRING
    )


@dataclass
class UpdateGroupRequest(betterproto.Message):
    """Update fields in a given group."""

    # The ID of the group to update.
    group_id: str = betterproto.string_field(1)
    # Name.
    name: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # Description string.
    description: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    # Lang tag.
    lang_tag: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    # Avatar URL.
    avatar_url: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    # Open is true if anyone should be allowed to join, or false if joins must be
    # approved by a group admin.
    open: Optional[bool] = betterproto.message_field(6, wraps=betterproto.TYPE_BOOL)


@dataclass
class User(betterproto.Message):
    """A user in the server."""

    # The id of the user's account.
    id: str = betterproto.string_field(1)
    # The username of the user's account.
    username: str = betterproto.string_field(2)
    # The display name of the user.
    display_name: str = betterproto.string_field(3)
    # A URL for an avatar image.
    avatar_url: str = betterproto.string_field(4)
    # The language expected to be a tag which follows the BCP-47 spec.
    lang_tag: str = betterproto.string_field(5)
    # The location set by the user.
    location: str = betterproto.string_field(6)
    # The timezone set by the user.
    timezone: str = betterproto.string_field(7)
    # Additional information stored as a JSON object.
    metadata: str = betterproto.string_field(8)
    # The Facebook id in the user's account.
    facebook_id: str = betterproto.string_field(9)
    # The Google id in the user's account.
    google_id: str = betterproto.string_field(10)
    # The Apple Game Center in of the user's account.
    gamecenter_id: str = betterproto.string_field(11)
    # The Steam id in the user's account.
    steam_id: str = betterproto.string_field(12)
    # Indicates whether the user is currently online.
    online: bool = betterproto.bool_field(13)
    # Number of related edges to this user.
    edge_count: int = betterproto.int32_field(14)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user was created.
    create_time: datetime = betterproto.message_field(15)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # user was last updated.
    update_time: datetime = betterproto.message_field(16)
    # The Facebook Instant Game ID in the user's account.
    facebook_instant_game_id: str = betterproto.string_field(17)
    # The Apple Sign In ID in the user's account.
    apple_id: str = betterproto.string_field(18)


@dataclass
class UserGroup(betterproto.Message):
    """A single group-role pair."""

    # Group.
    group: "Group" = betterproto.message_field(1)
    # The user's relationship to the group. -- use enum UserRoleState
    state: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)


@dataclass
class UserGroupsResponse(betterproto.Message):
    """
    A list of groups belonging to a user, along with the user's role in each
    group.
    """

    # Group-role pairs for a user.
    user_groups: List["UserGroup"] = betterproto.message_field(1)
    # Cursor for the next page of results, if any.
    cursor: str = betterproto.string_field(2)


@dataclass
class UsersResponse(betterproto.Message):
    """A collection of zero or more users."""

    # The User objects.
    users: List["User"] = betterproto.message_field(1)


@dataclass
class ValidatePurchaseAppleRequest(betterproto.Message):
    """Apple IAP Purchases validation request"""

    # Base64 encoded Apple receipt data payload.
    receipt: str = betterproto.string_field(1)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidateSubscriptionAppleRequest(betterproto.Message):
    """Apple Subscription validation request"""

    # Base64 encoded Apple receipt data payload.
    receipt: str = betterproto.string_field(1)
    # Persist the subscription.
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatePurchaseGoogleRequest(betterproto.Message):
    """Google IAP Purchase validation request"""

    # JSON encoded Google purchase payload.
    purchase: str = betterproto.string_field(1)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidateSubscriptionGoogleRequest(betterproto.Message):
    """Google Subscription validation request"""

    # JSON encoded Google purchase payload.
    receipt: str = betterproto.string_field(1)
    # Persist the subscription.
    persist: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatePurchaseHuaweiRequest(betterproto.Message):
    """Huawei IAP Purchase validation request"""

    # JSON encoded Huawei InAppPurchaseData.
    purchase: str = betterproto.string_field(1)
    # InAppPurchaseData signature.
    signature: str = betterproto.string_field(2)
    # Persist the purchase
    persist: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)


@dataclass
class ValidatedPurchase(betterproto.Message):
    """Validated Purchase stored by Nakama."""

    # Purchase User ID.
    user_id: str = betterproto.string_field(1)
    # Purchase Product ID.
    product_id: str = betterproto.string_field(2)
    # Purchase Transaction ID.
    transaction_id: str = betterproto.string_field(3)
    # Store identifier
    store: "StoreProvider" = betterproto.enum_field(4)
    # Timestamp when the purchase was done.
    purchase_time: datetime = betterproto.message_field(5)
    # Timestamp when the receipt validation was stored in DB.
    create_time: datetime = betterproto.message_field(6)
    # Timestamp when the receipt validation was updated in DB.
    update_time: datetime = betterproto.message_field(7)
    # Timestamp when the purchase was refunded. Set to UNIX
    refund_time: datetime = betterproto.message_field(8)
    # Raw provider validation response.
    provider_response: str = betterproto.string_field(9)
    # Whether the purchase was done in production or sandbox environment.
    environment: "StoreEnvironment" = betterproto.enum_field(10)
    # Whether the purchase had already been validated by Nakama before.
    seen_before: bool = betterproto.bool_field(11)


@dataclass
class ValidatePurchaseResponse(betterproto.Message):
    """Validate IAP response."""

    # Newly seen validated purchases.
    validated_purchases: List["ValidatedPurchase"] = betterproto.message_field(1)


@dataclass
class ValidateSubscriptionResponse(betterproto.Message):
    """Validate Subscription response."""

    validated_subscription: "ValidatedSubscription" = betterproto.message_field(1)


@dataclass
class ValidatedSubscription(betterproto.Message):
    # Subscription User ID.
    user_id: str = betterproto.string_field(1)
    # Purchase Product ID.
    product_id: str = betterproto.string_field(2)
    # Purchase Original transaction ID (we only keep track of the original
    # subscription, not subsequent renewals).
    original_transaction_id: str = betterproto.string_field(3)
    # Store identifier
    store: "StoreProvider" = betterproto.enum_field(4)
    # UNIX Timestamp when the purchase was done.
    purchase_time: datetime = betterproto.message_field(5)
    # UNIX Timestamp when the receipt validation was stored in DB.
    create_time: datetime = betterproto.message_field(6)
    # UNIX Timestamp when the receipt validation was updated in DB.
    update_time: datetime = betterproto.message_field(7)
    # Whether the purchase was done in production or sandbox environment.
    environment: "StoreEnvironment" = betterproto.enum_field(8)
    # Subscription expiration time. The subscription can still be auto-renewed to
    # extend the expiration time further.
    expiry_time: datetime = betterproto.message_field(9)
    # Subscription refund time. If this time is set, the subscription was
    # refunded.
    refund_time: datetime = betterproto.message_field(10)
    # Raw provider validation response body.
    provider_response: str = betterproto.string_field(11)
    # Raw provider notification body.
    provider_notification: str = betterproto.string_field(12)
    # Whether the subscription is currently active or not.
    active: bool = betterproto.bool_field(13)


@dataclass
class PurchasesResponse(betterproto.Message):
    """A list of validated purchases stored by Nakama."""

    # Stored validated purchases.
    validated_purchases: List["ValidatedPurchase"] = betterproto.message_field(1)
    # The cursor to send when retrieving the next page, if any.
    cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)


@dataclass
class SubscriptionsResponse(betterproto.Message):
    """A list of validated subscriptions stored by Nakama."""

    # Stored validated subscriptions.
    validated_subscriptions: List["ValidatedSubscription"] = betterproto.message_field(
        1
    )
    # The cursor to send when retrieving the next page, if any.
    cursor: str = betterproto.string_field(2)
    # The cursor to send when retrieving the previous page, if any.
    prev_cursor: str = betterproto.string_field(3)


@dataclass
class LeaderboardRecordWrite(betterproto.Message):
    """Record values to write."""

    # The score value to submit.
    score: int = betterproto.int64_field(1)
    # An optional secondary value.
    subscore: int = betterproto.int64_field(2)
    # Optional record metadata.
    metadata: str = betterproto.string_field(3)
    # Operator override.
    operator: "OpType" = betterproto.enum_field(4)


@dataclass
class WriteLeaderboardRecordRequest(betterproto.Message):
    """A request to submit a score to a leaderboard."""

    # The ID of the leaderboard to write to.
    leaderboard_id: str = betterproto.string_field(1)
    # Record input.
    record: "LeaderboardRecordWrite" = betterproto.message_field(2)


@dataclass
class WriteStorageObject(betterproto.Message):
    """The object to store."""

    # The collection to store the object.
    collection: str = betterproto.string_field(1)
    # The key for the object within the collection.
    key: str = betterproto.string_field(2)
    # The value of the object.
    value: str = betterproto.string_field(3)
    # The version hash of the object to check. Possible values are: ["", "*",
    # "#hash#"].
    version: str = betterproto.string_field(4)
    # The read access permissions for the object.
    permission_read: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_INT32
    )
    # The write access permissions for the object.
    permission_write: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_INT32
    )


@dataclass
class WriteStorageObjectsRequest(betterproto.Message):
    """Write objects to the storage engine."""

    # The objects to store on the server.
    objects: List["WriteStorageObject"] = betterproto.message_field(1)


@dataclass
class TournamentRecordWrite(betterproto.Message):
    """Record values to write."""

    # The score value to submit.
    score: int = betterproto.int64_field(1)
    # An optional secondary value.
    subscore: int = betterproto.int64_field(2)
    # A JSON object of additional properties (optional).
    metadata: str = betterproto.string_field(3)
    # Operator override.
    operator: "OpType" = betterproto.enum_field(4)


@dataclass
class WriteTournamentRecordRequest(betterproto.Message):
    """A request to submit a score to a tournament."""

    # The tournament ID to write the record for.
    tournament_id: str = betterproto.string_field(1)
    # Record input.
    record: "TournamentRecordWrite" = betterproto.message_field(2)


@dataclass
class Envelope(betterproto.Message):
    """An envelope for a realtime message."""

    cid: str = betterproto.string_field(1)
    # A response from a channel join operation.
    channel: "ChannelMsg" = betterproto.message_field(2, group="message")
    # Join a realtime chat channel.
    channel_join: "ChannelJoinMsg" = betterproto.message_field(3, group="message")
    # Leave a realtime chat channel.
    channel_leave: "ChannelLeaveMsg" = betterproto.message_field(4, group="message")
    # An incoming message on a realtime chat channel.
    channel_message: "ChannelMessage" = betterproto.message_field(5, group="message")
    # An acknowledgement received in response to sending a message on a chat
    # channel.
    channel_message_ack: "ChannelMessageAckMsg" = betterproto.message_field(
        6, group="message"
    )
    # Send a message to a realtime chat channel.
    channel_message_send: "ChannelMessageSendMsg" = betterproto.message_field(
        7, group="message"
    )
    # Update a message previously sent to a realtime chat channel.
    channel_message_update: "ChannelMessageUpdateMsg" = betterproto.message_field(
        8, group="message"
    )
    # Remove a message previously sent to a realtime chat channel.
    channel_message_remove: "ChannelMessageRemoveMsg" = betterproto.message_field(
        9, group="message"
    )
    # Presence update for a particular realtime chat channel.
    channel_presence_event: "ChannelPresenceEventMsg" = betterproto.message_field(
        10, group="message"
    )
    # Describes an error which occurred on the server.
    error: "ErrorMsg" = betterproto.message_field(11, group="message")
    # Incoming information about a realtime match.
    match: "MatchMsg" = betterproto.message_field(12, group="message")
    # A client to server request to create a realtime match.
    match_create: "MatchCreateMsg" = betterproto.message_field(13, group="message")
    # Incoming realtime match data delivered from the server.
    match_data: "MatchDataMsg" = betterproto.message_field(14, group="message")
    # A client to server request to send data to a realtime match.
    match_data_send: "MatchDataSendMsg" = betterproto.message_field(15, group="message")
    # A client to server request to join a realtime match.
    match_join: "MatchJoinMsg" = betterproto.message_field(16, group="message")
    # A client to server request to leave a realtime match.
    match_leave: "MatchLeaveMsg" = betterproto.message_field(17, group="message")
    # Presence update for a particular realtime match.
    match_presence_event: "MatchPresenceEventMsg" = betterproto.message_field(
        18, group="message"
    )
    # Submit a new matchmaking process request.
    matchmaker_add: "MatchmakerAddMsg" = betterproto.message_field(19, group="message")
    # A successful matchmaking result.
    matchmaker_matched: "MatchmakerMatchedMsg" = betterproto.message_field(
        20, group="message"
    )
    # Cancel a matchmaking process using a ticket.
    matchmaker_remove: "MatchmakerRemoveMsg" = betterproto.message_field(
        21, group="message"
    )
    # A response from starting a new matchmaking process.
    matchmaker_ticket: "MatchmakerTicketMsg" = betterproto.message_field(
        22, group="message"
    )
    # Notifications send by the server.
    notifications: "NotificationsMsg" = betterproto.message_field(23, group="message")
    # RPC call or response.
    rpc: "RpcMsg" = betterproto.message_field(24, group="message")
    # An incoming status snapshot for some set of users.
    status: "StatusMsg" = betterproto.message_field(25, group="message")
    # Start following some set of users to receive their status updates.
    status_follow: "StatusFollowMsg" = betterproto.message_field(26, group="message")
    # An incoming status update.
    status_presence_event: "StatusPresenceEventMsg" = betterproto.message_field(
        27, group="message"
    )
    # Stop following some set of users to no longer receive their status updates.
    status_unfollow: "StatusUnfollowMsg" = betterproto.message_field(
        28, group="message"
    )
    # Set the user's own status.
    status_update: "StatusUpdateMsg" = betterproto.message_field(29, group="message")
    # A data message delivered over a stream.
    stream_data: "StreamDataMsg" = betterproto.message_field(30, group="message")
    # Presence update for a particular stream.
    stream_presence_event: "StreamPresenceEventMsg" = betterproto.message_field(
        31, group="message"
    )
    # Application-level heartbeat and connection check.
    ping: "PingMsg" = betterproto.message_field(32, group="message")
    # Application-level heartbeat and connection check response.
    pong: "PongMsg" = betterproto.message_field(33, group="message")
    # Incoming information about a party.
    party: "PartyMsg" = betterproto.message_field(34, group="message")
    # Create a party.
    party_create: "PartyCreateMsg" = betterproto.message_field(35, group="message")
    # Join a party, or request to join if the party is not open.
    party_join: "PartyJoinMsg" = betterproto.message_field(36, group="message")
    # Leave a party.
    party_leave: "PartyLeaveMsg" = betterproto.message_field(37, group="message")
    # Promote a new party leader.
    party_promote: "PartyPromoteMsg" = betterproto.message_field(38, group="message")
    # Announcement of a new party leader.
    party_leader: "PartyLeaderMsg" = betterproto.message_field(39, group="message")
    # Accept a request to join.
    party_accept: "PartyAcceptMsg" = betterproto.message_field(40, group="message")
    # Kick a party member, or decline a request to join.
    party_remove: "PartyRemoveMsg" = betterproto.message_field(41, group="message")
    # End a party, kicking all party members and closing it.
    party_close: "PartyCloseMsg" = betterproto.message_field(42, group="message")
    # Request a list of pending join requests for a party.
    party_join_request_list: "PartyJoinRequestsMsg" = betterproto.message_field(
        43, group="message"
    )
    # Incoming notification for one or more new presences attempting to join the
    # party.
    party_join_request: "PartyJoinRequestMsg" = betterproto.message_field(
        44, group="message"
    )
    # Begin matchmaking as a party.
    party_matchmaker_add: "PartyMatchmakerAddMsg" = betterproto.message_field(
        45, group="message"
    )
    # Cancel a party matchmaking process using a ticket.
    party_matchmaker_remove: "PartyMatchmakerRemoveMsg" = betterproto.message_field(
        46, group="message"
    )
    # A response from starting a new party matchmaking process.
    party_matchmaker_ticket: "PartyMatchmakerTicketMsg" = betterproto.message_field(
        47, group="message"
    )
    # Incoming party data delivered from the server.
    party_data: "PartyDataMsg" = betterproto.message_field(48, group="message")
    # A client to server request to send data to a party.
    party_data_send: "PartyDataSendMsg" = betterproto.message_field(49, group="message")
    # Presence update for a particular party.
    party_presence_event: "PartyPresenceEventMsg" = betterproto.message_field(
        50, group="message"
    )


@dataclass
class ChannelMsg(betterproto.Message):
    """A realtime chat channel."""

    # The ID of the channel.
    id: str = betterproto.string_field(1)
    # The users currently in the channel.
    presences: List["UserPresenceMsg"] = betterproto.message_field(2)
    # A reference to the current user's presence in the channel.
    self: "UserPresenceMsg" = betterproto.message_field(3)
    # The name of the chat room, or an empty string if this message was not sent
    # through a chat room.
    room_name: str = betterproto.string_field(4)
    # The ID of the group, or an empty string if this message was not sent
    # through a group channel.
    group_id: str = betterproto.string_field(5)
    # The ID of the first DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_one: str = betterproto.string_field(6)
    # The ID of the second DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_two: str = betterproto.string_field(7)


@dataclass
class ChannelJoinMsg(betterproto.Message):
    """Join operation for a realtime chat channel."""

    # The user ID to DM with, group ID to chat with, or room channel name to
    # join.
    target: str = betterproto.string_field(1)
    # The type of the chat channel.
    type: int = betterproto.int32_field(2)
    # Whether messages sent on this channel should be persistent.
    persistence: Optional[bool] = betterproto.message_field(
        3, wraps=betterproto.TYPE_BOOL
    )
    # Whether the user should appear in the channel's presence list and events.
    hidden: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)


@dataclass
class ChannelLeaveMsg(betterproto.Message):
    """Leave a realtime channel."""

    # The ID of the channel to leave.
    channel_id: str = betterproto.string_field(1)


@dataclass
class ChannelMessageAckMsg(betterproto.Message):
    """A receipt reply from a channel message send operation."""

    # The channel the message was sent to.
    channel_id: str = betterproto.string_field(1)
    # The unique ID assigned to the message.
    message_id: str = betterproto.string_field(2)
    # The code representing a message type or category.
    code: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    # Username of the message sender.
    username: str = betterproto.string_field(4)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was created.
    create_time: datetime = betterproto.message_field(5)
    # The UNIX time (for gRPC clients) or ISO string (for REST clients) when the
    # message was created.
    update_time: datetime = betterproto.message_field(6)
    # True if the message was persisted to the channel's history, false
    # otherwise.
    persistent: Optional[bool] = betterproto.message_field(
        7, wraps=betterproto.TYPE_BOOL
    )
    # The name of the chat room, or an empty string if this message was not sent
    # through a chat room.
    room_name: str = betterproto.string_field(8)
    # The ID of the group, or an empty string if this message was not sent
    # through a group channel.
    group_id: str = betterproto.string_field(9)
    # The ID of the first DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_one: str = betterproto.string_field(10)
    # The ID of the second DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_two: str = betterproto.string_field(11)


@dataclass
class ChannelMessageSendMsg(betterproto.Message):
    """Send a message to a realtime channel."""

    # The channel to sent to.
    channel_id: str = betterproto.string_field(1)
    # Message content.
    content: str = betterproto.string_field(2)


@dataclass
class ChannelMessageUpdateMsg(betterproto.Message):
    """Update a message previously sent to a realtime channel."""

    # The channel the message was sent to.
    channel_id: str = betterproto.string_field(1)
    # The ID assigned to the message to update.
    message_id: str = betterproto.string_field(2)
    # New message content.
    content: str = betterproto.string_field(3)


@dataclass
class ChannelMessageRemoveMsg(betterproto.Message):
    """Remove a message previously sent to a realtime channel."""

    # The channel the message was sent to.
    channel_id: str = betterproto.string_field(1)
    # The ID assigned to the message to update.
    message_id: str = betterproto.string_field(2)


@dataclass
class ChannelPresenceEventMsg(betterproto.Message):
    """A set of joins and leaves on a particular channel."""

    # The channel identifier this event is for.
    channel_id: str = betterproto.string_field(1)
    # Presences joining the channel as part of this event, if any.
    joins: List["UserPresenceMsg"] = betterproto.message_field(2)
    # Presences leaving the channel as part of this event, if any.
    leaves: List["UserPresenceMsg"] = betterproto.message_field(3)
    # The name of the chat room, or an empty string if this message was not sent
    # through a chat room.
    room_name: str = betterproto.string_field(4)
    # The ID of the group, or an empty string if this message was not sent
    # through a group channel.
    group_id: str = betterproto.string_field(5)
    # The ID of the first DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_one: str = betterproto.string_field(6)
    # The ID of the second DM user, or an empty string if this message was not
    # sent through a DM chat.
    user_id_two: str = betterproto.string_field(7)


@dataclass
class ErrorMsg(betterproto.Message):
    """A logical error which may occur on the server."""

    # The error code which should be one of "Error.Code" enums.
    code: int = betterproto.int32_field(1)
    # A message in English to help developers debug the response.
    message: str = betterproto.string_field(2)
    # Additional error details which may be different for each response.
    context: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class MatchMsg(betterproto.Message):
    """A realtime match."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1)
    # True if it's an server-managed authoritative match, false otherwise.
    authoritative: bool = betterproto.bool_field(2)
    # Match label, if any.
    label: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # The number of users currently in the match.
    size: int = betterproto.int32_field(4)
    # The users currently in the match.
    presences: List["UserPresenceMsg"] = betterproto.message_field(5)
    # A reference to the current user's presence in the match.
    self: "UserPresenceMsg" = betterproto.message_field(6)


@dataclass
class MatchCreateMsg(betterproto.Message):
    """Create a new realtime match."""

    # Optional name to use when creating the match.
    name: str = betterproto.string_field(1)


@dataclass
class MatchDataMsg(betterproto.Message):
    """Realtime match data received from the server."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1)
    # A reference to the user presence that sent this data, if any.
    presence: "UserPresenceMsg" = betterproto.message_field(2)
    # Op code value.
    op_code: int = betterproto.int64_field(3)
    # Data payload, if any.
    data: bytes = betterproto.bytes_field(4)
    # True if this data was delivered reliably, false otherwise.
    reliable: bool = betterproto.bool_field(5)


@dataclass
class MatchDataSendMsg(betterproto.Message):
    """Send realtime match data to the server."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1)
    # Op code value.
    op_code: int = betterproto.int64_field(2)
    # Data payload, if any.
    data: bytes = betterproto.bytes_field(3)
    # List of presences in the match to deliver to, if filtering is required.
    # Otherwise deliver to everyone in the match.
    presences: List["UserPresenceMsg"] = betterproto.message_field(4)
    # True if the data should be sent reliably, false otherwise.
    reliable: bool = betterproto.bool_field(5)


@dataclass
class MatchJoinMsg(betterproto.Message):
    """Join an existing realtime match."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1, group="id")
    # A matchmaking result token.
    token: str = betterproto.string_field(2, group="id")
    # An optional set of key-value metadata pairs to be passed to the match
    # handler, if any.
    metadata: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class MatchLeaveMsg(betterproto.Message):
    """Leave a realtime match."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1)


@dataclass
class MatchPresenceEventMsg(betterproto.Message):
    """A set of joins and leaves on a particular realtime match."""

    # The match unique ID.
    match_id: str = betterproto.string_field(1)
    # User presences that have just joined the match.
    joins: List["UserPresenceMsg"] = betterproto.message_field(2)
    # User presences that have just left the match.
    leaves: List["UserPresenceMsg"] = betterproto.message_field(3)


@dataclass
class MatchmakerAddMsg(betterproto.Message):
    """Start a new matchmaking process."""

    # Minimum total user count to match together.
    min_count: int = betterproto.int32_field(1)
    # Maximum total user count to match together.
    max_count: int = betterproto.int32_field(2)
    # Filter query used to identify suitable users.
    query: str = betterproto.string_field(3)
    # String properties.
    string_properties: Dict[str, str] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Numeric properties.
    numeric_properties: Dict[str, float] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_DOUBLE
    )
    # Optional multiple of the count that must be satisfied.
    count_multiple: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_INT32
    )


@dataclass
class MatchmakerUserMsg(betterproto.Message):
    # User info.
    presence: "UserPresenceMsg" = betterproto.message_field(1)
    # Party identifier, if this user was matched as a party member.
    party_id: str = betterproto.string_field(2)
    # String properties.
    string_properties: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Numeric properties.
    numeric_properties: Dict[str, float] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_DOUBLE
    )


@dataclass
class MatchmakerMatchedMsg(betterproto.Message):
    """A successful matchmaking result."""

    # The matchmaking ticket that has completed.
    ticket: str = betterproto.string_field(1)
    # Match ID.
    match_id: str = betterproto.string_field(2, group="id")
    # Match join token.
    token: str = betterproto.string_field(3, group="id")
    # The users that have been matched together, and information about their
    # matchmaking data.
    users: List["MatchmakerUserMsg"] = betterproto.message_field(4)
    # A reference to the current user and their properties.
    self: "MatchmakerUserMsg" = betterproto.message_field(5)


@dataclass
class MatchmakerRemoveMsg(betterproto.Message):
    """Cancel an existing ongoing matchmaking process."""

    # The ticket to cancel.
    ticket: str = betterproto.string_field(1)


@dataclass
class MatchmakerTicketMsg(betterproto.Message):
    """A ticket representing a new matchmaking process."""

    # The ticket that can be used to cancel matchmaking.
    ticket: str = betterproto.string_field(1)


@dataclass
class NotificationsMsg(betterproto.Message):
    """A collection of zero or more notifications."""

    # Collection of notifications.
    notifications: List["Notification"] = betterproto.message_field(1)


@dataclass
class PartyMsg(betterproto.Message):
    """Incoming information about a party."""

    # Unique party identifier.
    party_id: str = betterproto.string_field(1)
    # Open flag.
    open: bool = betterproto.bool_field(2)
    # Maximum number of party members.
    max_size: int = betterproto.int32_field(3)
    # Self.
    self: "UserPresenceMsg" = betterproto.message_field(4)
    # Leader.
    leader: "UserPresenceMsg" = betterproto.message_field(5)
    # All current party members.
    presences: List["UserPresenceMsg"] = betterproto.message_field(6)


@dataclass
class PartyCreateMsg(betterproto.Message):
    """Create a party."""

    # Whether or not the party will require join requests to be approved by the
    # party leader.
    open: bool = betterproto.bool_field(1)
    # Maximum number of party members.
    max_size: int = betterproto.int32_field(2)


@dataclass
class PartyJoinMsg(betterproto.Message):
    """Join a party, or request to join if the party is not open."""

    # Party ID to join.
    party_id: str = betterproto.string_field(1)


@dataclass
class PartyLeaveMsg(betterproto.Message):
    """Leave a party."""

    # Party ID to leave.
    party_id: str = betterproto.string_field(1)


@dataclass
class PartyPromoteMsg(betterproto.Message):
    """Promote a new party leader."""

    # Party ID to promote a new leader for.
    party_id: str = betterproto.string_field(1)
    # The presence of an existing party member to promote as the new leader.
    presence: "UserPresenceMsg" = betterproto.message_field(2)


@dataclass
class PartyLeaderMsg(betterproto.Message):
    """Announcement of a new party leader."""

    # Party ID to announce the new leader for.
    party_id: str = betterproto.string_field(1)
    # The presence of the new party leader.
    presence: "UserPresenceMsg" = betterproto.message_field(2)


@dataclass
class PartyAcceptMsg(betterproto.Message):
    """Accept a request to join."""

    # Party ID to accept a join request for.
    party_id: str = betterproto.string_field(1)
    # The presence to accept as a party member.
    presence: "UserPresenceMsg" = betterproto.message_field(2)


@dataclass
class PartyRemoveMsg(betterproto.Message):
    """Kick a party member, or decline a request to join."""

    # Party ID to remove/reject from.
    party_id: str = betterproto.string_field(1)
    # The presence to remove or reject.
    presence: "UserPresenceMsg" = betterproto.message_field(2)


@dataclass
class PartyCloseMsg(betterproto.Message):
    """End a party, kicking all party members and closing it."""

    # Party ID to close.
    party_id: str = betterproto.string_field(1)


@dataclass
class PartyJoinRequestsMsg(betterproto.Message):
    """Request a list of pending join requests for a party."""

    # Party ID to get a list of join requests for.
    party_id: str = betterproto.string_field(1)


@dataclass
class PartyJoinRequestMsg(betterproto.Message):
    """
    Incoming notification for one or more new presences attempting to join the
    party.
    """

    # Party ID these presences are attempting to join.
    party_id: str = betterproto.string_field(1)
    # Presences attempting to join.
    presences: List["UserPresenceMsg"] = betterproto.message_field(2)


@dataclass
class PartyMatchmakerAddMsg(betterproto.Message):
    """Begin matchmaking as a party."""

    # Party ID.
    party_id: str = betterproto.string_field(1)
    # Minimum total user count to match together.
    min_count: int = betterproto.int32_field(2)
    # Maximum total user count to match together.
    max_count: int = betterproto.int32_field(3)
    # Filter query used to identify suitable users.
    query: str = betterproto.string_field(4)
    # String properties.
    string_properties: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Numeric properties.
    numeric_properties: Dict[str, float] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_DOUBLE
    )
    # Optional multiple of the count that must be satisfied.
    count_multiple: Optional[int] = betterproto.message_field(
        7, wraps=betterproto.TYPE_INT32
    )


@dataclass
class PartyMatchmakerRemoveMsg(betterproto.Message):
    """Cancel a party matchmaking process using a ticket."""

    # Party ID.
    party_id: str = betterproto.string_field(1)
    # The ticket to cancel.
    ticket: str = betterproto.string_field(2)


@dataclass
class PartyMatchmakerTicketMsg(betterproto.Message):
    """A response from starting a new party matchmaking process."""

    # Party ID.
    party_id: str = betterproto.string_field(1)
    # The ticket that can be used to cancel matchmaking.
    ticket: str = betterproto.string_field(2)


@dataclass
class PartyDataMsg(betterproto.Message):
    """Incoming party data delivered from the server."""

    # The party ID.
    party_id: str = betterproto.string_field(1)
    # A reference to the user presence that sent this data, if any.
    presence: "UserPresenceMsg" = betterproto.message_field(2)
    # Op code value.
    op_code: int = betterproto.int64_field(3)
    # Data payload, if any.
    data: bytes = betterproto.bytes_field(4)


@dataclass
class PartyDataSendMsg(betterproto.Message):
    """Send data to a party."""

    # Party ID to send to.
    party_id: str = betterproto.string_field(1)
    # Op code value.
    op_code: int = betterproto.int64_field(2)
    # Data payload, if any.
    data: bytes = betterproto.bytes_field(3)


@dataclass
class PartyPresenceEventMsg(betterproto.Message):
    """Presence update for a particular party."""

    # The party ID.
    party_id: str = betterproto.string_field(1)
    # User presences that have just joined the party.
    joins: List["UserPresenceMsg"] = betterproto.message_field(2)
    # User presences that have just left the party.
    leaves: List["UserPresenceMsg"] = betterproto.message_field(3)


@dataclass
class PingMsg(betterproto.Message):
    """Application-level heartbeat and connection check."""

    pass


@dataclass
class PongMsg(betterproto.Message):
    """Application-level heartbeat and connection check response."""

    pass


@dataclass
class StatusMsg(betterproto.Message):
    """A snapshot of statuses for some set of users."""

    # User statuses.
    presences: List["UserPresenceMsg"] = betterproto.message_field(1)


@dataclass
class StatusFollowMsg(betterproto.Message):
    """Start receiving status updates for some set of users."""

    # User IDs to follow.
    user_ids: List[str] = betterproto.string_field(1)
    # Usernames to follow.
    usernames: List[str] = betterproto.string_field(2)


@dataclass
class StatusPresenceEventMsg(betterproto.Message):
    """A batch of status updates for a given user."""

    # New statuses for the user.
    joins: List["UserPresenceMsg"] = betterproto.message_field(2)
    # Previous statuses for the user.
    leaves: List["UserPresenceMsg"] = betterproto.message_field(3)


@dataclass
class StatusUnfollowMsg(betterproto.Message):
    """Stop receiving status updates for some set of users."""

    # Users to unfollow.
    user_ids: List[str] = betterproto.string_field(1)


@dataclass
class StatusUpdateMsg(betterproto.Message):
    """Set the user's own status."""

    # Status string to set, if not present the user will appear offline.
    status: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)


@dataclass
class StreamMsg(betterproto.Message):
    """Represents identifying information for a stream."""

    # Mode identifies the type of stream.
    mode: int = betterproto.int32_field(1)
    # Subject is the primary identifier, if any.
    subject: str = betterproto.string_field(2)
    # Subcontext is a secondary identifier, if any.
    subcontext: str = betterproto.string_field(3)
    # The label is an arbitrary identifying string, if the stream has one.
    label: str = betterproto.string_field(4)


@dataclass
class StreamDataMsg(betterproto.Message):
    """A data message delivered over a stream."""

    # The stream this data message relates to.
    stream: "StreamMsg" = betterproto.message_field(1)
    # The sender, if any.
    sender: "UserPresenceMsg" = betterproto.message_field(2)
    # Arbitrary contents of the data message.
    data: str = betterproto.string_field(3)
    # True if this data was delivered reliably, false otherwise.
    reliable: bool = betterproto.bool_field(4)


@dataclass
class StreamPresenceEventMsg(betterproto.Message):
    """A set of joins and leaves on a particular stream."""

    # The stream this event relates to.
    stream: "StreamMsg" = betterproto.message_field(1)
    # Presences joining the stream as part of this event, if any.
    joins: List["UserPresenceMsg"] = betterproto.message_field(2)
    # Presences leaving the stream as part of this event, if any.
    leaves: List["UserPresenceMsg"] = betterproto.message_field(3)


@dataclass
class UserPresenceMsg(betterproto.Message):
    """
    A user session associated to a stream, usually through a list operation or
    a join/leave event.
    """

    # The user this presence belongs to.
    user_id: str = betterproto.string_field(1)
    # A unique session ID identifying the particular connection, because the user
    # may have many.
    session_id: str = betterproto.string_field(2)
    # The username for display purposes.
    username: str = betterproto.string_field(3)
    # Whether this presence generates persistent data/messages, if applicable for
    # the stream type.
    persistence: bool = betterproto.bool_field(4)
    # A user-set status message for this stream, if applicable.
    status: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
